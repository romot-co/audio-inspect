{"version":3,"sources":["../../src/features/time.ts"],"sourcesContent":["import { AudioData } from '../types.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100)\n  } = options;\n\n  // 解析対象のチャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // ピーク候補を検出\n  const peakCandidates = findPeakCandidates(channelData, threshold, minDistance);\n\n  // 振幅でソートして上位を選択\n  const sortedPeaks = peakCandidates.sort((a, b) => b.amplitude - a.amplitude).slice(0, count);\n\n  // 時間順にソート\n  sortedPeaks.sort((a, b) => a.position - b.position);\n\n  // 統計情報を計算\n  const maxAmplitude =\n    peakCandidates.length > 0 ? Math.max(...peakCandidates.map((p) => p.amplitude)) : 0;\n\n  const averageAmplitude =\n    peakCandidates.length > 0\n      ? peakCandidates.reduce((sum, p) => sum + p.amplitude, 0) / peakCandidates.length\n      : 0;\n\n  return {\n    peaks: sortedPeaks.map((candidate) => ({\n      position: candidate.position,\n      time: candidate.position / audio.sampleRate,\n      amplitude: candidate.amplitude\n    })),\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new Error(`無効なチャンネル番号: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new Error(`チャンネル ${channel} のデータが存在しません`);\n  }\n\n  return channelData;\n}\n\n/**\n * ピーク候補を検出\n */\nfunction findPeakCandidates(data: Float32Array, threshold: number, minDistance: number): Peak[] {\n  const peaks: Peak[] = [];\n  const length = data.length;\n\n  for (let i = 1; i < length - 1; i++) {\n    // 境界チェック済みなので安全にアクセス\n    const current = Math.abs(data[i] as number);\n    const prev = Math.abs(data[i - 1] as number);\n    const next = Math.abs(data[i + 1] as number);\n\n    // ローカルマキシマかつ閾値を超えているかチェック\n    if (current > prev && current > next && current > threshold) {\n      // 既存のピークとの最小距離をチェック\n      let shouldAdd = true;\n      let replaceIndex = -1;\n\n      for (let j = 0; j < peaks.length; j++) {\n        const peak = peaks[j] as Peak; // 配列内の要素なので存在保証\n        const distance = Math.abs(peak.position - i);\n        if (distance < minDistance) {\n          // 既存のピークと近すぎる\n          if (current > peak.amplitude) {\n            // より大きい振幅なので既存ピークを置き換え\n            replaceIndex = j;\n          }\n          shouldAdd = false;\n          break;\n        }\n      }\n\n      if (replaceIndex >= 0) {\n        // 既存ピークを置き換え\n        peaks[replaceIndex] = {\n          position: i,\n          time: 0,\n          amplitude: current\n        };\n      } else if (shouldAdd) {\n        // 新しいピークを追加\n        peaks.push({\n          position: i,\n          time: 0,\n          amplitude: current\n        });\n      }\n    }\n  }\n\n  return peaks;\n}\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  let sum = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i] as number;\n    sum += sample * sample;\n  }\n\n  return Math.sqrt(sum / channelData.length);\n}\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = channelData[i - 1] as number;\n    const current = channelData[i] as number;\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number;\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n *\n * @param audio - 音声データ\n * @param options - 波形データ取得オプション\n * @returns 波形データ\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // フレーム計算\n  const frameCount = Math.ceil(audio.duration * framesPerSecond);\n  const samplesPerFrame = Math.floor(audio.length / frameCount);\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム内のデータを抽出\n    const frameData = channelData.slice(startSample, endSample);\n\n    // 指定された方法で振幅を計算\n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n\n    waveform.push({ time, amplitude });\n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = frameData[i] as number;\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(frameData[i] as number);\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(frameData[i] as number);\n  }\n  return frameData.length > 0 ? sum / frameData.length : 0;\n}\n"],"mappings":"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","names":["channelData"]}