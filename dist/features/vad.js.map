{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/vad.ts"],"sourcesContent":["/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * チャンネルデータを安全に取得する共通関数\n * @param audio - AudioData オブジェクト\n * @param channel - チャンネル番号 (-1 で全チャンネルの平均)\n * @returns 指定されたチャンネルのデータ\n * @throws AudioInspectError チャンネルが無効な場合\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError(\n            'INVALID_INPUT',\n            `チャンネル ${ch} のデータが存在しません`\n          );\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}。有効範囲は 0-${audio.numberOfChannels - 1} または -1（平均）です`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n\n  return channelData;\n}\n\n/**\n * 数値が2の冪かどうかを判定\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * 次の2の冪を計算\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * 型安全な配列アクセス\n */\nexport function safeArrayAccess<T>(\n  array: ArrayLike<T>,\n  index: number,\n  defaultValue: T\n): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * 数値の妥当性を検証\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * サンプル値の安全な取得\n */\nexport function ensureValidSample(value: number | undefined | null, defaultValue: number = 0): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Float32Arrayの安全な確保\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * 振幅をdBに変換\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n  \n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n  \n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB \n    ? 20 * Math.log10(ratio) \n    : SILENCE_DB;\n}\n\n/**\n * dBを振幅に変換\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n} ","import { AudioData } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\n\nexport interface VADOptions {\n  channel?: number;\n  frameSizeMs?: number;\n  hopSizeMs?: number;\n  method?: 'energy' | 'zcr' | 'combined' | 'adaptive';\n  \n  // 閾値パラメータ\n  energyThreshold?: number;      // 固定エネルギー閾値\n  zcrThresholdLow?: number;      // ZCR下限（有声音）\n  zcrThresholdHigh?: number;     // ZCR上限（無声音）\n  \n  // 適応的閾値用パラメータ\n  adaptiveAlpha?: number;        // 適応率 (0-1)\n  noiseFactor?: number;          // ノイズレベルに対する倍率\n  \n  // 時間制約\n  minSilenceDurationMs?: number;\n  minSpeechDurationMs?: number;\n  \n  // 追加オプション\n  preEmphasis?: boolean;         // プリエンファシスフィルタ\n  smoothing?: boolean;           // 判定結果の平滑化\n}\n\nexport interface VADSegment {\n  start: number;\n  end: number;\n  type: 'speech' | 'silence';\n  confidence?: number;  // 判定の信頼度 (0-1)\n}\n\nexport interface VADResult {\n  segments: VADSegment[];\n  speechRatio: number;\n  features?: {\n    energies: Float32Array;\n    zcrs: Float32Array;\n    decisions: Float32Array;  // 0-1の連続値\n    times: Float32Array;\n  };\n}\n\n/**\n * プリエンファシスフィルタ\n */\nfunction applyPreEmphasis(data: Float32Array, alpha: number = 0.97): Float32Array {\n  const filtered = new Float32Array(data.length);\n  filtered[0] = data[0] || 0;\n  \n  for (let i = 1; i < data.length; i++) {\n    const current = ensureValidSample(data[i]);\n    const previous = ensureValidSample(data[i - 1]);\n    filtered[i] = current - alpha * previous;\n  }\n  \n  return filtered;\n}\n\n/**\n * フレームエネルギー計算\n */\nfunction calculateFrameEnergies(\n  channelData: Float32Array,\n  frameSizeSamples: number,\n  hopSizeSamples: number,\n  sampleRate: number,\n  useLogEnergy: boolean = false\n): { energies: Float32Array; times: Float32Array } {\n  const dataLength = channelData.length;\n  \n  if (dataLength < frameSizeSamples) {\n    return { energies: new Float32Array(0), times: new Float32Array(0) };\n  }\n\n  const frameCount = Math.floor((dataLength - frameSizeSamples) / hopSizeSamples) + 1;\n  const energies = new Float32Array(frameCount);\n  const times = new Float32Array(frameCount);\n\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSizeSamples;\n    const end = Math.min(start + frameSizeSamples, dataLength);\n    \n    let energy = 0;\n    let validSamples = 0;\n    \n    for (let j = start; j < end; j++) {\n      const sample = ensureValidSample(channelData[j]);\n      energy += sample * sample;\n      validSamples++;\n    }\n    \n    energy = validSamples > 0 ? energy / validSamples : 0; // 正規化\n    \n    if (useLogEnergy) {\n      energies[i] = energy > 1e-10 ? 10 * Math.log10(energy) : -100;\n    } else {\n      energies[i] = energy;\n    }\n    \n    times[i] = (start + frameSizeSamples / 2) / sampleRate;\n  }\n\n  return { energies, times };\n}\n\n/**\n * フレームZCR計算\n */\nfunction calculateFrameZCRs(\n  channelData: Float32Array,\n  frameSizeSamples: number,\n  hopSizeSamples: number,\n  normalize: boolean = true\n): Float32Array {\n  const dataLength = channelData.length;\n  \n  if (dataLength < frameSizeSamples) {\n    return new Float32Array(0);\n  }\n\n  const frameCount = Math.floor((dataLength - frameSizeSamples) / hopSizeSamples) + 1;\n  const zcrs = new Float32Array(frameCount);\n\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSizeSamples;\n    const end = Math.min(start + frameSizeSamples, dataLength);\n    \n    let crossings = 0;\n    let prevSign = Math.sign(ensureValidSample(channelData[start]));\n    \n    for (let j = start + 1; j < end; j++) {\n      const sample = ensureValidSample(channelData[j]);\n      const currentSign = Math.sign(sample);\n      if (prevSign !== currentSign && prevSign !== 0 && currentSign !== 0) {\n        crossings++;\n      }\n      prevSign = currentSign;\n    }\n    \n    zcrs[i] = normalize \n      ? crossings / Math.max(1, end - start - 1)\n      : crossings;\n  }\n\n  return zcrs;\n}\n\n/**\n * 適応的閾値の計算\n */\nfunction calculateAdaptiveThreshold(\n  values: Float32Array,\n  alpha: number,\n  noiseFactor: number,\n  initialFrames: number = 10\n): Float32Array {\n  const thresholds = new Float32Array(values.length);\n  \n  // 初期ノイズレベルの推定（最初のフレームから）\n  let noiseLevel = 0;\n  const noiseFrames = Math.min(initialFrames, values.length);\n  \n  for (let i = 0; i < noiseFrames; i++) {\n    const value = values[i];\n    if (value !== undefined) {\n      noiseLevel += value;\n    }\n  }\n  noiseLevel = noiseFrames > 0 ? noiseLevel / noiseFrames : 0;\n\n  // 適応的閾値の計算\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (value === undefined) {\n      thresholds[i] = i > 0 ? (thresholds[i - 1] ?? noiseLevel * noiseFactor) : noiseLevel * noiseFactor;\n      continue;\n    }\n\n    if (i === 0) {\n      thresholds[i] = noiseLevel * noiseFactor;\n    } else {\n      const prevThreshold = thresholds[i - 1];\n      // 指数移動平均によるノイズレベルの更新\n      if (prevThreshold !== undefined && value < prevThreshold) {\n        noiseLevel = alpha * noiseLevel + (1 - alpha) * value;\n      }\n      thresholds[i] = noiseLevel * noiseFactor;\n    }\n  }\n\n  return thresholds;\n}\n\n/**\n * 判定結果の平滑化（メディアンフィルタ）\n */\nfunction smoothDecisions(\n  decisions: Float32Array,\n  windowSize: number = 5\n): Float32Array {\n  const smoothed = new Float32Array(decisions.length);\n  const halfWindow = Math.floor(windowSize / 2);\n\n  for (let i = 0; i < decisions.length; i++) {\n    const start = Math.max(0, i - halfWindow);\n    const end = Math.min(decisions.length, i + halfWindow + 1);\n    \n    // 窓内の値を収集してソート\n    const windowValues: number[] = [];\n    for (let j = start; j < end; j++) {\n      const value = decisions[j];\n      if (value !== undefined) {\n        windowValues.push(value);\n      }\n    }\n    windowValues.sort((a, b) => a - b);\n    \n    // メディアン値を取得\n    if (windowValues.length > 0) {\n      const medianIdx = Math.floor(windowValues.length / 2);\n      const medianValue = windowValues[medianIdx];\n      smoothed[i] = medianValue ?? 0;\n    } else {\n      smoothed[i] = 0;\n    }\n  }\n\n  return smoothed;\n}\n\n/**\n * セグメント化（連続値から）\n */\nfunction createSegmentsFromContinuous(\n  decisions: Float32Array,\n  times: Float32Array,\n  threshold: number = 0.5,\n  minSpeechSec: number = 0.1,\n  minSilenceSec: number = 0.3\n): VADSegment[] {\n  const segments: VADSegment[] = [];\n  let currentSegment: VADSegment | null = null;\n\n  for (let i = 0; i < decisions.length; i++) {\n    const decision = decisions[i];\n    const time = times[i];\n    if (decision === undefined || time === undefined) continue;\n\n    const isSpeech = decision >= threshold;\n\n    if (!currentSegment) {\n      currentSegment = {\n        start: time,\n        end: time,\n        type: isSpeech ? 'speech' : 'silence',\n        confidence: Math.abs(decision - 0.5) * 2\n      };\n    } else if ((isSpeech && currentSegment.type === 'speech') || \n               (!isSpeech && currentSegment.type === 'silence')) {\n      // 同じタイプのセグメントを延長\n      currentSegment.end = time;\n      const conf = Math.abs(decision - 0.5) * 2;\n      currentSegment.confidence = Math.max(currentSegment.confidence || 0, conf);\n    } else {\n      // タイプが変わった場合\n      segments.push(currentSegment);\n      currentSegment = {\n        start: time,\n        end: time,\n        type: isSpeech ? 'speech' : 'silence',\n        confidence: Math.abs(decision - 0.5) * 2\n      };\n    }\n  }\n\n  if (currentSegment) {\n    segments.push(currentSegment);\n  }\n\n  // 短いセグメントのフィルタリング\n  return filterShortSegments(segments, minSpeechSec, minSilenceSec);\n}\n\n/**\n * 短いセグメントのフィルタリング\n */\nfunction filterShortSegments(\n  segments: VADSegment[],\n  minSpeechSec: number,\n  minSilenceSec: number\n): VADSegment[] {\n  if (segments.length === 0) return [];\n\n  const filtered: VADSegment[] = [];\n  let i = 0;\n\n  while (i < segments.length) {\n    const current = segments[i];\n    if (!current) {\n      i++;\n      continue;\n    }\n\n    const duration = current.end - current.start;\n\n    if ((current.type === 'speech' && duration >= minSpeechSec) ||\n        (current.type === 'silence' && duration >= minSilenceSec)) {\n      // セグメントを保持\n      filtered.push(current);\n      i++;\n    } else {\n      // 短いセグメントの処理\n      if (filtered.length > 0 && i + 1 < segments.length) {\n        const prev = filtered[filtered.length - 1];\n        const next = segments[i + 1];\n\n        if (prev && next && prev.type === next.type) {\n          // 前後が同じタイプなら統合\n          prev.end = next.end;\n          i += 2; // 現在と次のセグメントをスキップ\n          continue;\n        }\n      }\n      \n      // 統合できない場合はタイプを変更\n      if (filtered.length > 0) {\n        const lastFiltered = filtered[filtered.length - 1];\n        if (lastFiltered) {\n          lastFiltered.end = current.end;\n        }\n      }\n      i++;\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * VAD（音声区間検出）を実行\n */\nexport function getVAD(\n  audio: AudioData,\n  options: VADOptions = {}\n): VADResult {\n  const {\n    channel = 0,\n    frameSizeMs = 30,      // 30msフレーム\n    hopSizeMs = 10,        // 10msホップ\n    method = 'combined',\n    energyThreshold = 0.02,\n    zcrThresholdLow = 0.05,\n    zcrThresholdHigh = 0.15,\n    adaptiveAlpha = 0.99,\n    noiseFactor = 3.0,\n    minSilenceDurationMs = 300,\n    minSpeechDurationMs = 100,\n    preEmphasis = true,\n    smoothing = true\n  } = options;\n\n  let channelData = getChannelData(audio, channel);\n  \n  // プリエンファシス（オプション）\n  if (preEmphasis) {\n    channelData = applyPreEmphasis(channelData);\n  }\n\n  const sr = audio.sampleRate;\n  const frameSizeSamples = Math.floor(frameSizeMs / 1000 * sr);\n  const hopSizeSamples = Math.floor(hopSizeMs / 1000 * sr);\n\n  if (frameSizeSamples === 0 || hopSizeSamples === 0) {\n    return { segments: [], speechRatio: 0 };\n  }\n\n  // 特徴量の計算\n  const { energies, times } = calculateFrameEnergies(\n    channelData, \n    frameSizeSamples, \n    hopSizeSamples, \n    sr, \n    false\n  );\n  \n  const zcrs = calculateFrameZCRs(\n    channelData, \n    frameSizeSamples, \n    hopSizeSamples, \n    true\n  );\n\n  if (energies.length === 0) {\n    return { segments: [], speechRatio: 0 };\n  }\n\n  // VAD判定\n  const decisions = new Float32Array(energies.length);\n\n  switch (method) {\n    case 'energy': {\n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        decisions[i] = energy !== undefined && energy > energyThreshold ? 1 : 0;\n      }\n      break;\n    }\n    \n    case 'zcr': {\n      for (let i = 0; i < zcrs.length; i++) {\n        const zcr = zcrs[i];\n        decisions[i] = zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 1 : 0;\n      }\n      break;\n    }\n    \n    case 'combined': {\n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        const zcr = zcrs[i];\n        \n        const energyScore = energy !== undefined && energy > energyThreshold ? 1 : 0;\n        const zcrScore = zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 1 : 0;\n        decisions[i] = (energyScore + zcrScore) / 2;\n      }\n      break;\n    }\n    \n    case 'adaptive': {\n      // 適応的閾値の計算\n      const adaptiveThreshold = calculateAdaptiveThreshold(\n        energies,\n        adaptiveAlpha,\n        noiseFactor\n      );\n      \n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        const zcr = zcrs[i];\n        const threshold = adaptiveThreshold[i];\n        \n        const energyScore = energy !== undefined && threshold !== undefined && energy > threshold ? 1 : 0;\n        const zcrScore = zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 0.5 : 0;\n        decisions[i] = Math.min(1, energyScore + zcrScore);\n      }\n      break;\n    }\n  }\n\n  // 平滑化（オプション）\n  const finalDecisions = smoothing \n    ? smoothDecisions(decisions, 5) \n    : decisions;\n\n  // セグメント化\n  const minSpeechSec = minSpeechDurationMs / 1000;\n  const minSilenceSec = minSilenceDurationMs / 1000;\n  \n  const segments = createSegmentsFromContinuous(\n    finalDecisions,\n    times,\n    0.5,\n    minSpeechSec,\n    minSilenceSec\n  );\n\n  // 音声区間の割合計算\n  let totalSpeechDuration = 0;\n  for (const seg of segments) {\n    if (seg.type === 'speech') {\n      totalSpeechDuration += seg.end - seg.start;\n    }\n  }\n  \n  const speechRatio = audio.duration > 0 \n    ? Math.min(1, totalSpeechDuration / audio.duration) \n    : 0;\n\n  return {\n    segments,\n    speechRatio,\n    features: {\n      energies,\n      zcrs,\n      decisions: finalDecisions,\n      times\n    }\n  };\n} "],"mappings":"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","names":["channelData"]}