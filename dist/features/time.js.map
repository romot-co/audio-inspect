{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/time.ts"],"sourcesContent":["/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * フォールバック機能付きストリーミングオプション\n */\nexport interface StreamOptionsWithFallback extends StreamOptions {\n  /** フォールバック処理を有効にするか */\n  enableFallback?: boolean;\n  /** フォールバック時のハンドラー */\n  fallbackHandler?: (audio: AudioData) => void;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED'\n  | 'WORKLET_NOT_SUPPORTED' // AudioWorkletサポートなし\n  | 'MODULE_LOAD_FAILED'; // モジュール読み込み失敗\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage\n  | CleanupMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * クリーンアップメッセージ\n */\nexport interface CleanupMessage {\n  type: 'cleanup';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n","import { AudioData, AmplitudeOptions, AudioInspectError } from '../types.js';\nimport {\n  getChannelData,\n  ensureValidSample,\n  isValidSample,\n  amplitudeToDecibels,\n  safeArrayAccess\n} from '../core/utils.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\ninterface PeakCandidate {\n  position: number;\n  amplitude: number;\n  prominence?: number; // ピークの顕著性（オプション）\n}\n\n// より洗練されたピーク検出アルゴリズム\nfunction detectAllInitialPeaks(\n  data: Float32Array,\n  threshold: number,\n  includeProminence: boolean = false\n): PeakCandidate[] {\n  const peaks: PeakCandidate[] = [];\n  const length = data.length;\n\n  if (length < 3) return peaks; // 最低3サンプル必要\n\n  for (let i = 1; i < length - 1; i++) {\n    const current = Math.abs(ensureValidSample(data[i]));\n    const prev = Math.abs(ensureValidSample(data[i - 1]));\n    const next = Math.abs(ensureValidSample(data[i + 1]));\n\n    // ローカルマキシマムかつ閾値を超えているか\n    if (current > prev && current > next && current > threshold) {\n      const peak: PeakCandidate = {\n        position: i,\n        amplitude: current\n      };\n\n      // オプション：ピークの顕著性を計算\n      if (includeProminence) {\n        peak.prominence = calculateProminence(data, i, current);\n      }\n\n      peaks.push(peak);\n    }\n  }\n\n  return peaks;\n}\n\n// ピークの顕著性を計算（オプション機能）\nfunction calculateProminence(data: Float32Array, peakIndex: number, peakValue: number): number {\n  // 左側の最小値を探索\n  let leftMin = peakValue;\n  for (let i = peakIndex - 1; i >= 0; i--) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    leftMin = Math.min(leftMin, value);\n  }\n\n  // 右側の最小値を探索\n  let rightMin = peakValue;\n  for (let i = peakIndex + 1; i < data.length; i++) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    rightMin = Math.min(rightMin, value);\n  }\n\n  return peakValue - Math.max(leftMin, rightMin);\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100) // デフォルト10ms\n  } = options;\n\n  if (count <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'ピーク数は正の整数である必要があります');\n  }\n\n  if (threshold < 0 || threshold > 1) {\n    throw new AudioInspectError('INVALID_INPUT', '閾値は0から1の範囲である必要があります');\n  }\n\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 1. すべての初期ピーク候補を検出\n  const allInitialPeaks = detectAllInitialPeaks(channelData, threshold);\n\n  if (allInitialPeaks.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 2. 振幅の降順でソート\n  allInitialPeaks.sort((a, b) => b.amplitude - a.amplitude);\n\n  // 3. 空間的フィルタリング（最小距離制約）\n  const selectedPeaks: Peak[] = [];\n  const occupiedRegions: Array<[number, number]> = []; // [start, end]の配列\n\n  for (const candidate of allInitialPeaks) {\n    if (selectedPeaks.length >= count) break;\n\n    // 占有領域との重複をチェック\n    const candidateStart = candidate.position - minDistance;\n    const candidateEnd = candidate.position + minDistance;\n\n    const hasOverlap = occupiedRegions.some(\n      ([start, end]) => !(candidateEnd < start || candidateStart > end)\n    );\n\n    if (!hasOverlap) {\n      selectedPeaks.push({\n        position: candidate.position,\n        time: candidate.position / audio.sampleRate,\n        amplitude: candidate.amplitude\n      });\n\n      occupiedRegions.push([candidateStart, candidateEnd]);\n    }\n  }\n\n  // 4. 時間順でソート\n  selectedPeaks.sort((a, b) => a.position - b.position);\n\n  // 5. 統計情報の計算（すべての候補から）\n  const maxAmplitude = allInitialPeaks.length > 0 ? (allInitialPeaks[0]?.amplitude ?? 0) : 0;\n  const averageAmplitude =\n    allInitialPeaks.length > 0\n      ? allInitialPeaks.reduce((sum, p) => sum + p.amplitude, 0) / allInitialPeaks.length\n      : 0;\n\n  return {\n    peaks: selectedPeaks,\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n// 定数定義\nconst SILENCE_DB = -Infinity;\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(audio: AudioData, optionsOrChannel: AmplitudeOptions | number = {}): number {\n  const options: Required<AmplitudeOptions> =\n    typeof optionsOrChannel === 'number'\n      ? { channel: optionsOrChannel, asDB: false, reference: 1.0 }\n      : {\n          channel: 0,\n          asDB: false,\n          reference: 1.0,\n          ...optionsOrChannel\n        };\n\n  const channelData = getChannelData(audio, options.channel);\n\n  if (channelData.length === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  // RMS計算（数値的安定性を考慮）\n  let sumOfSquares = 0;\n  let validSampleCount = 0;\n\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      sumOfSquares += sample * sample;\n      validSampleCount++;\n    }\n  }\n\n  if (validSampleCount === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  const rms = Math.sqrt(sumOfSquares / validSampleCount);\n\n  return options.asDB ? amplitudeToDecibels(rms, options.reference) : rms;\n}\n\n/**\n * ピーク振幅を計算\n */\nexport function getPeakAmplitude(audio: AudioData, options: AmplitudeOptions = {}): number {\n  const resolvedOptions: Required<AmplitudeOptions> = {\n    channel: 0,\n    asDB: false,\n    reference: 1.0,\n    ...options\n  };\n\n  const channelData = getChannelData(audio, resolvedOptions.channel);\n\n  if (channelData.length === 0) {\n    return resolvedOptions.asDB ? SILENCE_DB : 0;\n  }\n\n  let peak = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      peak = Math.max(peak, Math.abs(sample));\n    }\n  }\n\n  return resolvedOptions.asDB ? amplitudeToDecibels(peak, resolvedOptions.reference) : peak;\n}\n\n// エイリアスとしてgetPeakをエクスポート\nexport { getPeakAmplitude as getPeak };\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length < 2) {\n    return 0;\n  }\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = ensureValidSample(channelData[i - 1]);\n    const current = ensureValidSample(channelData[i]);\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number; // nullを許容しない設計\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  const channelData = getChannelData(audio, channel);\n\n  // 修正2.3: 極端なフレーム数指定時の不具合対応\n  // audio.length が0の場合は frameCount も0にする\n  const desiredFrameCount = Math.ceil(audio.duration * framesPerSecond);\n  const maxPossibleFrameCount = audio.length > 0 ? audio.length : desiredFrameCount > 0 ? 1 : 0;\n  const frameCount = Math.min(desiredFrameCount, maxPossibleFrameCount);\n\n  const samplesPerFrame = frameCount > 0 ? Math.max(1, Math.floor(audio.length / frameCount)) : 0;\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム長が0または負の場合の処理\n    if (endSample <= startSample) {\n      // 最後の有効な振幅値を使用、または0\n      const lastAmplitude =\n        waveform.length > 0\n          ? safeArrayAccess(waveform, waveform.length - 1, { time: 0, amplitude: 0 }).amplitude\n          : 0;\n\n      waveform.push({\n        time: (startSample + samplesPerFrame / 2) / audio.sampleRate,\n        amplitude: lastAmplitude\n      });\n      continue;\n    }\n\n    // フレームデータの処理\n    const frameData = channelData.subarray(startSample, endSample); // sliceより効率的\n\n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n    waveform.push({ time, amplitude });\n\n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = ensureValidSample(frameData[i]);\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(ensureValidSample(frameData[i]));\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(ensureValidSample(frameData[i]));\n  }\n  return sum / frameData.length;\n}\n"],"mappings":"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","names":["channelData","SILENCE_DB"]}