{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/time.ts"],"sourcesContent":["/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * チャンネルデータを安全に取得する共通関数\n * @param audio - AudioData オブジェクト\n * @param channel - チャンネル番号 (-1 で全チャンネルの平均)\n * @returns 指定されたチャンネルのデータ\n * @throws AudioInspectError チャンネルが無効な場合\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError(\n            'INVALID_INPUT',\n            `チャンネル ${ch} のデータが存在しません`\n          );\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}。有効範囲は 0-${audio.numberOfChannels - 1} または -1（平均）です`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n\n  return channelData;\n}\n\n/**\n * 数値が2の冪かどうかを判定\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * 次の2の冪を計算\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * 型安全な配列アクセス\n */\nexport function safeArrayAccess<T>(\n  array: ArrayLike<T>,\n  index: number,\n  defaultValue: T\n): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * 数値の妥当性を検証\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * サンプル値の安全な取得\n */\nexport function ensureValidSample(value: number | undefined | null, defaultValue: number = 0): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Float32Arrayの安全な確保\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * 振幅をdBに変換\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n  \n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n  \n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB \n    ? 20 * Math.log10(ratio) \n    : SILENCE_DB;\n}\n\n/**\n * dBを振幅に変換\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n} ","import { AudioData, AmplitudeOptions, AudioInspectError } from '../types.js';\nimport { getChannelData, ensureValidSample, isValidSample, amplitudeToDecibels, safeArrayAccess } from '../core/utils.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\ninterface PeakCandidate {\n  position: number;\n  amplitude: number;\n  prominence?: number; // ピークの顕著性（オプション）\n}\n\n// より洗練されたピーク検出アルゴリズム\nfunction detectAllInitialPeaks(\n  data: Float32Array, \n  threshold: number,\n  includeProminence: boolean = false\n): PeakCandidate[] {\n  const peaks: PeakCandidate[] = [];\n  const length = data.length;\n\n  if (length < 3) return peaks; // 最低3サンプル必要\n\n  for (let i = 1; i < length - 1; i++) {\n    const current = Math.abs(ensureValidSample(data[i]));\n    const prev = Math.abs(ensureValidSample(data[i - 1]));\n    const next = Math.abs(ensureValidSample(data[i + 1]));\n\n    // ローカルマキシマムかつ閾値を超えているか\n    if (current > prev && current > next && current > threshold) {\n      const peak: PeakCandidate = {\n        position: i,\n        amplitude: current\n      };\n\n      // オプション：ピークの顕著性を計算\n      if (includeProminence) {\n        peak.prominence = calculateProminence(data, i, current);\n      }\n\n      peaks.push(peak);\n    }\n  }\n  \n  return peaks;\n}\n\n// ピークの顕著性を計算（オプション機能）\nfunction calculateProminence(data: Float32Array, peakIndex: number, peakValue: number): number {\n  // 左側の最小値を探索\n  let leftMin = peakValue;\n  for (let i = peakIndex - 1; i >= 0; i--) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    leftMin = Math.min(leftMin, value);\n  }\n\n  // 右側の最小値を探索\n  let rightMin = peakValue;\n  for (let i = peakIndex + 1; i < data.length; i++) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    rightMin = Math.min(rightMin, value);\n  }\n\n  return peakValue - Math.max(leftMin, rightMin);\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100) // デフォルト10ms\n  } = options;\n\n  if (count <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'ピーク数は正の整数である必要があります');\n  }\n\n  if (threshold < 0 || threshold > 1) {\n    throw new AudioInspectError('INVALID_INPUT', '閾値は0から1の範囲である必要があります');\n  }\n\n  const channelData = getChannelData(audio, channel);\n  \n  if (channelData.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 1. すべての初期ピーク候補を検出\n  const allInitialPeaks = detectAllInitialPeaks(channelData, threshold);\n\n  if (allInitialPeaks.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 2. 振幅の降順でソート\n  allInitialPeaks.sort((a, b) => b.amplitude - a.amplitude);\n\n  // 3. 空間的フィルタリング（最小距離制約）\n  const selectedPeaks: Peak[] = [];\n  const occupiedRegions: Array<[number, number]> = []; // [start, end]の配列\n\n  for (const candidate of allInitialPeaks) {\n    if (selectedPeaks.length >= count) break;\n\n    // 占有領域との重複をチェック\n    const candidateStart = candidate.position - minDistance;\n    const candidateEnd = candidate.position + minDistance;\n    \n    const hasOverlap = occupiedRegions.some(([start, end]) => \n      !(candidateEnd < start || candidateStart > end)\n    );\n\n    if (!hasOverlap) {\n      selectedPeaks.push({\n        position: candidate.position,\n        time: candidate.position / audio.sampleRate,\n        amplitude: candidate.amplitude\n      });\n      \n      occupiedRegions.push([candidateStart, candidateEnd]);\n    }\n  }\n\n  // 4. 時間順でソート\n  selectedPeaks.sort((a, b) => a.position - b.position);\n\n  // 5. 統計情報の計算（すべての候補から）\n  const maxAmplitude = allInitialPeaks.length > 0 ? (allInitialPeaks[0]?.amplitude ?? 0) : 0;\n  const averageAmplitude = allInitialPeaks.length > 0 \n    ? allInitialPeaks.reduce((sum, p) => sum + p.amplitude, 0) / allInitialPeaks.length\n    : 0;\n\n  return {\n    peaks: selectedPeaks,\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n// 定数定義\nconst SILENCE_DB = -Infinity;\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(\n  audio: AudioData,\n  optionsOrChannel: AmplitudeOptions | number = {}\n): number {\n  const options: Required<AmplitudeOptions> = typeof optionsOrChannel === 'number'\n    ? { channel: optionsOrChannel, asDB: false, reference: 1.0 }\n    : { \n        channel: 0, \n        asDB: false, \n        reference: 1.0,\n        ...optionsOrChannel \n      };\n\n  const channelData = getChannelData(audio, options.channel);\n\n  if (channelData.length === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  // RMS計算（数値的安定性を考慮）\n  let sumOfSquares = 0;\n  let validSampleCount = 0;\n\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      sumOfSquares += sample * sample;\n      validSampleCount++;\n    }\n  }\n\n  if (validSampleCount === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  const rms = Math.sqrt(sumOfSquares / validSampleCount);\n\n  return options.asDB \n    ? amplitudeToDecibels(rms, options.reference)\n    : rms;\n}\n\n/**\n * ピーク振幅を計算\n */\nexport function getPeakAmplitude(\n  audio: AudioData,\n  options: AmplitudeOptions = {}\n): number {\n  const resolvedOptions: Required<AmplitudeOptions> = {\n    channel: 0,\n    asDB: false,\n    reference: 1.0,\n    ...options\n  };\n\n  const channelData = getChannelData(audio, resolvedOptions.channel);\n\n  if (channelData.length === 0) {\n    return resolvedOptions.asDB ? SILENCE_DB : 0;\n  }\n\n  let peak = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      peak = Math.max(peak, Math.abs(sample));\n    }\n  }\n\n  return resolvedOptions.asDB \n    ? amplitudeToDecibels(peak, resolvedOptions.reference)\n    : peak;\n}\n\n// エイリアスとしてgetPeakをエクスポート\nexport { getPeakAmplitude as getPeak };\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length < 2) {\n    return 0;\n  }\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = ensureValidSample(channelData[i - 1]);\n    const current = ensureValidSample(channelData[i]);\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number; // nullを許容しない設計\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  const channelData = getChannelData(audio, channel);\n\n  // フレーム計算\n  const frameCount = Math.ceil(audio.duration * framesPerSecond);\n  const samplesPerFrame = Math.floor(audio.length / frameCount);\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム長が0または負の場合の処理\n    if (endSample <= startSample) {\n      // 最後の有効な振幅値を使用、または0\n      const lastAmplitude = waveform.length > 0 \n        ? safeArrayAccess(waveform, waveform.length - 1, { time: 0, amplitude: 0 }).amplitude\n        : 0;\n      \n      waveform.push({\n        time: (startSample + samplesPerFrame / 2) / audio.sampleRate,\n        amplitude: lastAmplitude\n      });\n      continue;\n    }\n\n    // フレームデータの処理\n    const frameData = channelData.subarray(startSample, endSample); // sliceより効率的\n    \n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n    waveform.push({ time, amplitude });\n    \n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n  \n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = ensureValidSample(frameData[i]);\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(ensureValidSample(frameData[i]));\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n  \n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(ensureValidSample(frameData[i]));\n  }\n  return sum / frameData.length;\n}\n"],"mappings":"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","names":["channelData","SILENCE_DB"]}