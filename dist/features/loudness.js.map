{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/loudness.ts"],"sourcesContent":["/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * フォールバック機能付きストリーミングオプション\n */\nexport interface StreamOptionsWithFallback extends StreamOptions {\n  /** フォールバック処理を有効にするか */\n  enableFallback?: boolean;\n  /** フォールバック時のハンドラー */\n  fallbackHandler?: (audio: AudioData) => void;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED'\n  | 'WORKLET_NOT_SUPPORTED' // AudioWorkletサポートなし\n  | 'MODULE_LOAD_FAILED'; // モジュール読み込み失敗\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage\n  | CleanupMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * クリーンアップメッセージ\n */\nexport interface CleanupMessage {\n  type: 'cleanup';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { ensureValidSample } from '../core/utils.js';\n\n// ITU-R BS.1770-4準拠の定数\nconst ABSOLUTE_GATE_LUFS = -70.0;\nconst RELATIVE_GATE_LU = 10.0;\nconst BLOCK_SIZE_MS = 400;\nconst BLOCK_OVERLAP = 0.75; // 75%オーバーラップ\nconst SHORT_TERM_WINDOW_MS = 3000;\nconst MOMENTARY_WINDOW_MS = 400;\n\n// K-weighting filter coefficients (ITU-R BS.1770-4)\nconst K_WEIGHTING_STAGE1 = {\n  // High-pass filter (Butterworth)\n  b: [1.53512485958697, -2.69169618940638, 1.19839281085285],\n  a: [1.0, -1.69065929318241, 0.73248077421585]\n};\n\nconst K_WEIGHTING_STAGE2 = {\n  // High-frequency shelf\n  b: [1.53660026327012, -2.68908427791073, 1.16158667615261],\n  a: [1.0, -1.68859431835989, 0.72909998803284]\n};\n\n// Biquadフィルタの状態\ninterface BiquadState {\n  x1: number;\n  x2: number;\n  y1: number;\n  y2: number;\n}\n\n// Biquadフィルタの適用\nfunction applyBiquad(\n  input: Float32Array,\n  b: number[],\n  a: number[],\n  state: BiquadState = { x1: 0, x2: 0, y1: 0, y2: 0 }\n): Float32Array {\n  const output = new Float32Array(input.length);\n  let { x1, x2, y1, y2 } = state;\n\n  for (let i = 0; i < input.length; i++) {\n    const x0 = ensureValidSample(input[i]);\n    const b0 = b[0] ?? 0;\n    const b1 = b[1] ?? 0;\n    const b2 = b[2] ?? 0;\n    const a1 = a[1] ?? 0;\n    const a2 = a[2] ?? 0;\n\n    const y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;\n\n    output[i] = y0;\n\n    x2 = x1;\n    x1 = x0;\n    y2 = y1;\n    y1 = y0;\n  }\n\n  // 状態を更新\n  state.x1 = x1;\n  state.x2 = x2;\n  state.y1 = y1;\n  state.y2 = y2;\n\n  return output;\n}\n\n// K-weightingフィルタの適用\nfunction applyKWeighting(channelData: Float32Array): Float32Array {\n  // ステージ1: ハイパスフィルタ\n  let filtered = applyBiquad(channelData, K_WEIGHTING_STAGE1.b, K_WEIGHTING_STAGE1.a);\n\n  // ステージ2: 高周波シェルフ\n  filtered = applyBiquad(filtered, K_WEIGHTING_STAGE2.b, K_WEIGHTING_STAGE2.a);\n\n  return filtered;\n}\n\n// ブロックのラウドネス計算\nfunction calculateBlockLoudness(channels: Float32Array[]): number {\n  let sumOfSquares = 0;\n  const numChannels = channels.length;\n\n  if (numChannels === 0) return -Infinity;\n\n  for (let ch = 0; ch < numChannels; ch++) {\n    const channelData = channels[ch];\n    if (!channelData || channelData.length === 0) continue;\n\n    let channelSum = 0;\n    let validSamples = 0;\n\n    for (let i = 0; i < channelData.length; i++) {\n      const sample = ensureValidSample(channelData[i]);\n      channelSum += sample * sample;\n      validSamples++;\n    }\n\n    if (validSamples === 0) continue;\n\n    // チャンネル重み付け（ステレオの場合）\n    const channelWeight = 1.0; // L, R, Cは1.0、Ls, Rsは1.41（サラウンドの場合）\n    sumOfSquares += channelWeight * (channelSum / validSamples);\n  }\n\n  // LUFSに変換\n  return -0.691 + 10 * Math.log10(Math.max(1e-15, sumOfSquares));\n}\n\nexport interface LUFSOptions {\n  channelMode?: 'mono' | 'stereo';\n  gated?: boolean;\n  calculateShortTerm?: boolean;\n  calculateMomentary?: boolean;\n  calculateLoudnessRange?: boolean;\n  calculateTruePeak?: boolean;\n}\n\nexport interface LUFSResult {\n  integrated: number; // Integrated loudness (LUFS)\n  shortTerm?: Float32Array; // Short-term loudness values\n  momentary?: Float32Array; // Momentary loudness values\n  loudnessRange?: number; // Loudness range (LU)\n  truePeak?: number[]; // True peak per channel (dBTP)\n  statistics?: {\n    percentile10: number; // 10th percentile\n    percentile95: number; // 95th percentile\n  };\n}\n\nexport function getLUFS(audio: AudioData, options: LUFSOptions = {}): LUFSResult {\n  const {\n    channelMode = audio.numberOfChannels >= 2 ? 'stereo' : 'mono',\n    gated = true,\n    calculateShortTerm = false,\n    calculateMomentary = false,\n    calculateLoudnessRange = false,\n    calculateTruePeak = false\n  } = options;\n\n  if (audio.numberOfChannels === 0) {\n    throw new AudioInspectError('INVALID_INPUT', '処理可能なチャンネルがありません');\n  }\n\n  // チャンネルデータの準備\n  const channelsToProcess: Float32Array[] = [];\n\n  if (channelMode === 'mono') {\n    const channel0 = audio.channelData[0];\n    if (channel0) {\n      channelsToProcess.push(channel0);\n    }\n  } else {\n    // ステレオ処理\n    const channel0 = audio.channelData[0];\n    const channel1 = audio.channelData[1];\n    if (channel0) channelsToProcess.push(channel0);\n    if (channel1) channelsToProcess.push(channel1);\n  }\n\n  if (channelsToProcess.length === 0) {\n    throw new AudioInspectError('INVALID_INPUT', '処理可能なチャンネルがありません');\n  }\n\n  // K-weightingの適用\n  const kWeightedChannels = channelsToProcess.map((ch) => applyKWeighting(ch));\n\n  // ブロック処理のパラメータ\n  const sampleRate = audio.sampleRate;\n  const blockSizeSamples = Math.floor((BLOCK_SIZE_MS / 1000) * sampleRate);\n  const hopSizeSamples = Math.floor(blockSizeSamples * (1 - BLOCK_OVERLAP));\n  const dataLength = kWeightedChannels[0]?.length ?? 0;\n\n  if (dataLength === 0) {\n    return { integrated: -Infinity };\n  }\n\n  // Integrated Loudness の計算\n  const blockLoudnessValues: number[] = [];\n\n  for (let pos = 0; pos + blockSizeSamples <= dataLength; pos += hopSizeSamples) {\n    const blockChannels = kWeightedChannels.map((ch) => ch.subarray(pos, pos + blockSizeSamples));\n\n    const loudness = calculateBlockLoudness(blockChannels);\n    if (isFinite(loudness)) {\n      blockLoudnessValues.push(loudness);\n    }\n  }\n\n  let integratedLoudness = -Infinity;\n\n  if (blockLoudnessValues.length > 0) {\n    let finalLoudnessValues = [...blockLoudnessValues];\n\n    if (gated) {\n      // 絶対ゲート（-70 LUFS）\n      finalLoudnessValues = finalLoudnessValues.filter((l) => l >= ABSOLUTE_GATE_LUFS);\n\n      if (finalLoudnessValues.length > 0) {\n        // 相対ゲートのための平均計算\n        const sumPower = finalLoudnessValues.reduce((sum, lufs) => {\n          return sum + Math.pow(10, (lufs + 0.691) / 10);\n        }, 0);\n\n        const meanLoudness = -0.691 + 10 * Math.log10(sumPower / finalLoudnessValues.length);\n        const relativeThreshold = meanLoudness - RELATIVE_GATE_LU;\n\n        // 相対ゲート適用\n        finalLoudnessValues = finalLoudnessValues.filter((l) => l >= relativeThreshold);\n      }\n    }\n\n    if (finalLoudnessValues.length > 0) {\n      // 最終的なIntegrated Loudness\n      const sumPower = finalLoudnessValues.reduce((sum, lufs) => {\n        return sum + Math.pow(10, (lufs + 0.691) / 10);\n      }, 0);\n\n      integratedLoudness = -0.691 + 10 * Math.log10(sumPower / finalLoudnessValues.length);\n    }\n  }\n\n  const result: LUFSResult = {\n    integrated: integratedLoudness\n  };\n\n  // Short-term Loudness（オプション）\n  if (calculateShortTerm) {\n    const shortTermSamples = Math.floor((SHORT_TERM_WINDOW_MS / 1000) * sampleRate);\n    const shortTermHop = hopSizeSamples;\n    const shortTermValues: number[] = [];\n\n    for (let pos = 0; pos + shortTermSamples <= dataLength; pos += shortTermHop) {\n      const windowChannels = kWeightedChannels.map((ch) =>\n        ch.subarray(pos, pos + shortTermSamples)\n      );\n\n      const loudness = calculateBlockLoudness(windowChannels);\n      if (isFinite(loudness)) {\n        shortTermValues.push(loudness);\n      }\n    }\n\n    result.shortTerm = new Float32Array(shortTermValues);\n  }\n\n  // Momentary Loudness（オプション）\n  if (calculateMomentary) {\n    const momentarySamples = Math.floor((MOMENTARY_WINDOW_MS / 1000) * sampleRate);\n    const momentaryHop = hopSizeSamples;\n    const momentaryValues: number[] = [];\n\n    for (let pos = 0; pos + momentarySamples <= dataLength; pos += momentaryHop) {\n      const windowChannels = kWeightedChannels.map((ch) =>\n        ch.subarray(pos, pos + momentarySamples)\n      );\n\n      const loudness = calculateBlockLoudness(windowChannels);\n      if (isFinite(loudness)) {\n        momentaryValues.push(loudness);\n      }\n    }\n\n    result.momentary = new Float32Array(momentaryValues);\n  }\n\n  // Loudness Range（オプション）\n  if (calculateLoudnessRange && result.shortTerm) {\n    const validValues = Array.from(result.shortTerm)\n      .filter((v) => v > ABSOLUTE_GATE_LUFS && isFinite(v))\n      .sort((a, b) => a - b);\n\n    if (validValues.length > 0) {\n      const percentile10Index = Math.floor(validValues.length * 0.1);\n      const percentile95Index = Math.floor(validValues.length * 0.95);\n\n      const percentile10 = validValues[percentile10Index] ?? -Infinity;\n      const percentile95 = validValues[percentile95Index] ?? -Infinity;\n\n      result.loudnessRange = percentile95 - percentile10;\n      result.statistics = { percentile10, percentile95 };\n    }\n  }\n\n  // True Peak（オプション - 簡易実装）\n  if (calculateTruePeak) {\n    result.truePeak = channelsToProcess.map((ch) => {\n      let peak = 0;\n      for (const sample of ch) {\n        const sampleValue = ensureValidSample(sample);\n        peak = Math.max(peak, Math.abs(sampleValue));\n      }\n      return peak > 0 ? 20 * Math.log10(peak) : -Infinity;\n    });\n  }\n\n  return result;\n}\n"],"mappings":"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","names":[]}