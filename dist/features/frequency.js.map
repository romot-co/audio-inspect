{"version":3,"sources":["../../src/types.ts","../../src/core/fft-provider.ts","../../src/features/frequency.ts"],"sourcesContent":["/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<void>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n// WebFFT型定義\ninterface WebFFTInstance {\n  fft(input: Float32Array): Float32Array;\n  profile(): Promise<unknown>;\n  dispose(): void;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: WebFFTInstance | null = null;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {}\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const webfftModule = await import('webfft');\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      const WebFFTConstructor = webfftModule.default as any;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      this.fftInstance = new WebFFTConstructor(this.size) as WebFFTInstance;\n\n      if (this.enableProfiling && this.fftInstance?.profile) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<void> {\n    if (!this.fftInstance || !this.fftInstance.profile) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    await this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance && this.fftInstance.dispose) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * 効率的なネイティブFFTプロバイダー（Cooley-Tukey実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  private bitReversalTable!: Uint32Array;\n  private twiddleFactorsReal!: Float32Array;\n  private twiddleFactorsImag!: Float32Array;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        'FFTサイズは2の冪である必要があります'\n      );\n    }\n    this.precomputeTables();\n  }\n\n  get name(): string {\n    return 'Native FFT (Cooley-Tukey)';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  private precomputeTables(): void {\n    // ビット反転テーブルの事前計算\n    this.bitReversalTable = new Uint32Array(this.size);\n    const bits = Math.log2(this.size);\n    for (let i = 0; i < this.size; i++) {\n      let reversed = 0;\n      for (let j = 0; j < bits; j++) {\n        reversed = (reversed << 1) | ((i >> j) & 1);\n      }\n      this.bitReversalTable[i] = reversed;\n    }\n\n    // Twiddle factorsの事前計算\n    const halfSize = this.size / 2;\n    this.twiddleFactorsReal = new Float32Array(halfSize);\n    this.twiddleFactorsImag = new Float32Array(halfSize);\n    for (let i = 0; i < halfSize; i++) {\n      const angle = -2 * Math.PI * i / this.size;\n      this.twiddleFactorsReal[i] = Math.cos(angle);\n      this.twiddleFactorsImag[i] = Math.sin(angle);\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // 複素数配列の初期化（ビット反転順）\n    const real = new Float32Array(this.size);\n    const imag = new Float32Array(this.size);\n    \n    for (let i = 0; i < this.size; i++) {\n      const reversedIndex = this.bitReversalTable[i];\n      if (reversedIndex !== undefined) {\n        real[reversedIndex] = input[i] || 0;\n        imag[reversedIndex] = 0;\n      }\n    }\n\n    // Cooley-Tukey FFTアルゴリズム\n    for (let stage = 1; stage < this.size; stage *= 2) {\n      const stageSize = stage * 2;\n      const twiddleStep = this.size / stageSize;\n      \n      for (let k = 0; k < this.size; k += stageSize) {\n        for (let j = 0; j < stage; j++) {\n          const twiddleIndex = j * twiddleStep;\n          const wr = this.twiddleFactorsReal[twiddleIndex] || 0;\n          const wi = this.twiddleFactorsImag[twiddleIndex] || 0;\n          \n          const evenIndex = k + j;\n          const oddIndex = k + j + stage;\n          \n          const evenReal = real[evenIndex] || 0;\n          const evenImag = imag[evenIndex] || 0;\n          const oddReal = real[oddIndex] || 0;\n          const oddImag = imag[oddIndex] || 0;\n          \n          const tempReal = oddReal * wr - oddImag * wi;\n          const tempImag = oddReal * wi + oddImag * wr;\n          \n          real[evenIndex] = evenReal + tempReal;\n          imag[evenIndex] = evenImag + tempImag;\n          real[oddIndex] = evenReal - tempReal;\n          imag[oddIndex] = evenImag - tempImag;\n        }\n      }\n    }\n\n    // 結果の構築\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < this.size; i++) {\n      complex[i * 2] = real[i] || 0;\n      complex[i * 2 + 1] = imag[i] || 0;\n      \n      if (i <= this.size / 2) {\n        const realPart = real[i] || 0;\n        const imagPart = imag[i] || 0;\n        magnitude[i] = Math.sqrt(realPart * realPart + imagPart * imagPart);\n        phase[i] = Math.atan2(imagPart, realPart);\n        frequencies[i] = (i * this.sampleRate) / this.size;\n      }\n    }\n\n    return { complex, magnitude, phase, frequencies };\n  }\n\n  dispose(): void {\n    // メモリの明示的な解放（必要に応じて）\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft': {\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider.initializeWebFFT();\n        return provider;\n      }\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default: {\n        const exhaustiveCheck: never = config.type;\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${String(exhaustiveCheck)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { FFTProviderFactory, type FFTProviderType, type FFTResult } from '../core/fft-provider.js';\n\n/**\n * FFT分析のオプション\n */\nexport interface FFTOptions {\n  /** FFTサイズ（デフォルト: 2048、2の累乗である必要があります） */\n  fftSize?: number;\n  /** ウィンドウ関数（デフォルト: 'hann'） */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** オーバーラップ率（デフォルト: 0.5） */\n  overlap?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** FFTプロバイダー（デフォルト: 'webfft'） */\n  provider?: FFTProviderType;\n  /** プロファイリングを有効にする（WebFFTのみ） */\n  enableProfiling?: boolean;\n}\n\n/**\n * スペクトラム解析のオプション\n */\nexport interface SpectrumOptions extends FFTOptions {\n  /** 最小周波数（Hz、デフォルト: 0） */\n  minFrequency?: number;\n  /** 最大周波数（Hz、デフォルト: ナイキスト周波数） */\n  maxFrequency?: number;\n  /** dB表示かどうか（デフォルト: true） */\n  decibels?: boolean;\n  /** 時間フレーム数（スペクトログラム用、デフォルト: 100） */\n  timeFrames?: number;\n}\n\n/**\n * スペクトログラムデータ\n */\nexport interface SpectrogramData {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** 周波数軸（Hz） */\n  frequencies: Float32Array;\n  /** 強度データ（時間 x 周波数） */\n  intensities: Float32Array[];\n  /** フレーム数 */\n  timeFrames: number;\n  /** 周波数ビン数 */\n  frequencyBins: number;\n}\n\n/**\n * FFT分析結果\n */\nexport interface FFTAnalysisResult extends FFTResult {\n  /** FFTサイズ */\n  fftSize: number;\n  /** 使用されたウィンドウ関数 */\n  windowFunction: string;\n  /** プロバイダー名 */\n  providerName: string;\n}\n\n/**\n * スペクトラム解析結果\n */\nexport interface SpectrumAnalysisResult {\n  /** 周波数（Hz） */\n  frequencies: Float32Array;\n  /** 強度 */\n  magnitudes: Float32Array;\n  /** dB値（decielsオプションがtrueの場合） */\n  decibels?: Float32Array;\n  /** スペクトログラム（timeFrames > 1の場合） */\n  spectrogram?: SpectrogramData;\n}\n\n/**\n * ウィンドウ関数を適用\n */\nfunction applyWindow(data: Float32Array, windowType: string): Float32Array {\n  const windowed = new Float32Array(data.length);\n  const N = data.length;\n\n  for (let i = 0; i < N; i++) {\n    let windowValue = 1;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n        break;\n      case 'blackman':\n        windowValue =\n          0.42 -\n          0.5 * Math.cos((2 * Math.PI * i) / (N - 1)) +\n          0.08 * Math.cos((4 * Math.PI * i) / (N - 1));\n        break;\n      case 'none':\n      default:\n        windowValue = 1;\n        break;\n    }\n\n    windowed[i] = (data[i] || 0) * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `無効なチャンネル番号: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `チャンネル ${channel} のデータが存在しません`);\n  }\n\n  return channelData;\n}\n\n/**\n * FFT分析を行う\n *\n * @param audio - 音声データ\n * @param options - FFTオプション\n * @returns FFT結果\n */\nexport async function getFFT(\n  audio: AudioData,\n  options: FFTOptions = {}\n): Promise<FFTAnalysisResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    provider = 'webfft',\n    enableProfiling = false\n  } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // FFTサイズが入力より大きい場合、ゼロパディング\n  let inputData: Float32Array;\n  if (channelData.length < fftSize) {\n    inputData = new Float32Array(fftSize);\n    inputData.set(channelData);\n  } else {\n    inputData = channelData.slice(0, fftSize);\n  }\n\n  // ウィンドウ関数を適用\n  const windowedData = applyWindow(inputData, windowFunction);\n\n  // FFTプロバイダーを作成\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: provider,\n    fftSize,\n    sampleRate: audio.sampleRate,\n    enableProfiling\n  });\n\n  try {\n    // FFTを実行\n    const result = fftProvider.fft(windowedData);\n\n    return {\n      ...result,\n      fftSize,\n      windowFunction,\n      providerName: fftProvider.name\n    };\n  } finally {\n    // リソースを解放\n    fftProvider.dispose();\n  }\n}\n\n/**\n * スペクトラム解析を行う\n *\n * @param audio - 音声データ\n * @param options - スペクトラムオプション\n * @returns スペクトラム解析結果\n */\nexport async function getSpectrum(\n  audio: AudioData,\n  options: SpectrumOptions = {}\n): Promise<SpectrumAnalysisResult> {\n  const {\n    fftSize = 2048,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    decibels = true,\n    timeFrames = 1,\n    overlap = 0.5,\n    ...fftOptions\n  } = options;\n\n  const channelData = getChannelData(audio, options.channel || 0);\n\n  if (timeFrames === 1) {\n    // 単一フレームのスペクトラム解析\n    const fftResult = await getFFT(audio, { ...fftOptions, fftSize });\n\n    // 周波数範囲をフィルタリング\n    const filteredResult = filterFrequencyRange(fftResult, minFrequency, maxFrequency);\n\n    const result: SpectrumAnalysisResult = {\n      frequencies: filteredResult.frequencies,\n      magnitudes: filteredResult.magnitude\n    };\n\n    if (decibels) {\n      result.decibels = magnitudeToDecibels(filteredResult.magnitude);\n    }\n\n    return result;\n  } else {\n    // スペクトログラム解析\n    const spectrogram = await computeSpectrogram(\n      channelData,\n      audio.sampleRate,\n      fftSize,\n      timeFrames,\n      overlap,\n      { ...fftOptions, minFrequency, maxFrequency, decibels }\n    );\n\n    return {\n      frequencies: spectrogram.frequencies,\n      magnitudes: new Float32Array(), // スペクトログラムでは個別のmagnitudesは空\n      spectrogram\n    };\n  }\n}\n\n/**\n * 周波数範囲をフィルタリング\n */\nfunction filterFrequencyRange(fftResult: FFTResult, minFreq: number, maxFreq: number): FFTResult {\n  const { frequencies, magnitude, phase, complex } = fftResult;\n\n  const startIndex = frequencies.findIndex((f) => f >= minFreq);\n  const endIndex = frequencies.findIndex((f) => f > maxFreq);\n  const actualEndIndex = endIndex === -1 ? frequencies.length : endIndex;\n\n  return {\n    frequencies: frequencies.slice(startIndex, actualEndIndex),\n    magnitude: magnitude.slice(startIndex, actualEndIndex),\n    phase: phase.slice(startIndex, actualEndIndex),\n    complex: complex.slice(startIndex * 2, actualEndIndex * 2)\n  };\n}\n\n/**\n * 振幅をdBに変換\n */\nfunction magnitudeToDecibels(magnitude: Float32Array): Float32Array {\n  const decibels = new Float32Array(magnitude.length);\n  for (let i = 0; i < magnitude.length; i++) {\n    const mag = magnitude[i] || 0;\n    decibels[i] = mag > 0 ? 20 * Math.log10(mag) : -Infinity;\n  }\n  return decibels;\n}\n\n/**\n * スペクトログラム計算のオプション\n */\ninterface SpectrogramOptions {\n  provider?: FFTProviderType;\n  enableProfiling?: boolean;\n  windowFunction?: string;\n  minFrequency?: number;\n  maxFrequency?: number;\n  decibels?: boolean;\n}\n\n/**\n * スペクトログラムを計算\n */\nasync function computeSpectrogram(\n  data: Float32Array,\n  sampleRate: number,\n  fftSize: number,\n  timeFrames: number,\n  overlap: number,\n  options: SpectrogramOptions\n): Promise<SpectrogramData> {\n  const hopSize = Math.floor(fftSize * (1 - overlap));\n  const actualFrames = Math.min(timeFrames, Math.floor((data.length - fftSize) / hopSize) + 1);\n\n  const times = new Float32Array(actualFrames);\n  const intensities: Float32Array[] = [];\n  let frequencies: Float32Array = new Float32Array();\n\n  // FFTプロバイダーを作成（一度だけ）\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: options.provider || 'webfft',\n    fftSize,\n    sampleRate,\n    enableProfiling: options.enableProfiling || false\n  });\n\n  try {\n    for (let frame = 0; frame < actualFrames; frame++) {\n      const startSample = frame * hopSize;\n\n      // フレームデータを抽出\n      const frameData = new Float32Array(fftSize);\n      for (let i = 0; i < fftSize && startSample + i < data.length; i++) {\n        frameData[i] = data[startSample + i] || 0;\n      }\n\n      // ウィンドウ関数を適用\n      const windowedData = applyWindow(frameData, options.windowFunction || 'hann');\n\n      // FFTを実行\n      const fftResult = fftProvider.fft(windowedData);\n\n      // 最初のフレームで周波数軸を設定\n      if (frame === 0) {\n        frequencies = fftResult.frequencies;\n      }\n\n      // 強度データを保存\n      const magnitude = fftResult.magnitude;\n      const frameIntensity = options.decibels ? magnitudeToDecibels(magnitude) : magnitude;\n      intensities.push(frameIntensity);\n\n      // 時間位置を計算\n      times[frame] = (startSample + fftSize / 2) / sampleRate;\n    }\n  } finally {\n    fftProvider.dispose();\n  }\n\n  return {\n    times,\n    frequencies,\n    intensities,\n    timeFrames: actualFrames,\n    frequencyBins: frequencies.length\n  };\n}\n"],"mappings":"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","names":["channelData"]}