{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/time.ts","../../src/core/fft-provider.ts","../../src/features/frequency.ts","../../src/features/spectral.ts","../../src/features/energy.ts","../../src/features/dynamics.ts","../../src/features/stereo.ts","../../src/features/vad.ts","../../src/features/loudness.ts"],"sourcesContent":["/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED';\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n","import { AudioData, AmplitudeOptions, AudioInspectError } from '../types.js';\nimport {\n  getChannelData,\n  ensureValidSample,\n  isValidSample,\n  amplitudeToDecibels,\n  safeArrayAccess\n} from '../core/utils.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\ninterface PeakCandidate {\n  position: number;\n  amplitude: number;\n  prominence?: number; // ピークの顕著性（オプション）\n}\n\n// より洗練されたピーク検出アルゴリズム\nfunction detectAllInitialPeaks(\n  data: Float32Array,\n  threshold: number,\n  includeProminence: boolean = false\n): PeakCandidate[] {\n  const peaks: PeakCandidate[] = [];\n  const length = data.length;\n\n  if (length < 3) return peaks; // 最低3サンプル必要\n\n  for (let i = 1; i < length - 1; i++) {\n    const current = Math.abs(ensureValidSample(data[i]));\n    const prev = Math.abs(ensureValidSample(data[i - 1]));\n    const next = Math.abs(ensureValidSample(data[i + 1]));\n\n    // ローカルマキシマムかつ閾値を超えているか\n    if (current > prev && current > next && current > threshold) {\n      const peak: PeakCandidate = {\n        position: i,\n        amplitude: current\n      };\n\n      // オプション：ピークの顕著性を計算\n      if (includeProminence) {\n        peak.prominence = calculateProminence(data, i, current);\n      }\n\n      peaks.push(peak);\n    }\n  }\n\n  return peaks;\n}\n\n// ピークの顕著性を計算（オプション機能）\nfunction calculateProminence(data: Float32Array, peakIndex: number, peakValue: number): number {\n  // 左側の最小値を探索\n  let leftMin = peakValue;\n  for (let i = peakIndex - 1; i >= 0; i--) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    leftMin = Math.min(leftMin, value);\n  }\n\n  // 右側の最小値を探索\n  let rightMin = peakValue;\n  for (let i = peakIndex + 1; i < data.length; i++) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    rightMin = Math.min(rightMin, value);\n  }\n\n  return peakValue - Math.max(leftMin, rightMin);\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100) // デフォルト10ms\n  } = options;\n\n  if (count <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'ピーク数は正の整数である必要があります');\n  }\n\n  if (threshold < 0 || threshold > 1) {\n    throw new AudioInspectError('INVALID_INPUT', '閾値は0から1の範囲である必要があります');\n  }\n\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 1. すべての初期ピーク候補を検出\n  const allInitialPeaks = detectAllInitialPeaks(channelData, threshold);\n\n  if (allInitialPeaks.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 2. 振幅の降順でソート\n  allInitialPeaks.sort((a, b) => b.amplitude - a.amplitude);\n\n  // 3. 空間的フィルタリング（最小距離制約）\n  const selectedPeaks: Peak[] = [];\n  const occupiedRegions: Array<[number, number]> = []; // [start, end]の配列\n\n  for (const candidate of allInitialPeaks) {\n    if (selectedPeaks.length >= count) break;\n\n    // 占有領域との重複をチェック\n    const candidateStart = candidate.position - minDistance;\n    const candidateEnd = candidate.position + minDistance;\n\n    const hasOverlap = occupiedRegions.some(\n      ([start, end]) => !(candidateEnd < start || candidateStart > end)\n    );\n\n    if (!hasOverlap) {\n      selectedPeaks.push({\n        position: candidate.position,\n        time: candidate.position / audio.sampleRate,\n        amplitude: candidate.amplitude\n      });\n\n      occupiedRegions.push([candidateStart, candidateEnd]);\n    }\n  }\n\n  // 4. 時間順でソート\n  selectedPeaks.sort((a, b) => a.position - b.position);\n\n  // 5. 統計情報の計算（すべての候補から）\n  const maxAmplitude = allInitialPeaks.length > 0 ? (allInitialPeaks[0]?.amplitude ?? 0) : 0;\n  const averageAmplitude =\n    allInitialPeaks.length > 0\n      ? allInitialPeaks.reduce((sum, p) => sum + p.amplitude, 0) / allInitialPeaks.length\n      : 0;\n\n  return {\n    peaks: selectedPeaks,\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n// 定数定義\nconst SILENCE_DB = -Infinity;\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(audio: AudioData, optionsOrChannel: AmplitudeOptions | number = {}): number {\n  const options: Required<AmplitudeOptions> =\n    typeof optionsOrChannel === 'number'\n      ? { channel: optionsOrChannel, asDB: false, reference: 1.0 }\n      : {\n          channel: 0,\n          asDB: false,\n          reference: 1.0,\n          ...optionsOrChannel\n        };\n\n  const channelData = getChannelData(audio, options.channel);\n\n  if (channelData.length === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  // RMS計算（数値的安定性を考慮）\n  let sumOfSquares = 0;\n  let validSampleCount = 0;\n\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      sumOfSquares += sample * sample;\n      validSampleCount++;\n    }\n  }\n\n  if (validSampleCount === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  const rms = Math.sqrt(sumOfSquares / validSampleCount);\n\n  return options.asDB ? amplitudeToDecibels(rms, options.reference) : rms;\n}\n\n/**\n * ピーク振幅を計算\n */\nexport function getPeakAmplitude(audio: AudioData, options: AmplitudeOptions = {}): number {\n  const resolvedOptions: Required<AmplitudeOptions> = {\n    channel: 0,\n    asDB: false,\n    reference: 1.0,\n    ...options\n  };\n\n  const channelData = getChannelData(audio, resolvedOptions.channel);\n\n  if (channelData.length === 0) {\n    return resolvedOptions.asDB ? SILENCE_DB : 0;\n  }\n\n  let peak = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      peak = Math.max(peak, Math.abs(sample));\n    }\n  }\n\n  return resolvedOptions.asDB ? amplitudeToDecibels(peak, resolvedOptions.reference) : peak;\n}\n\n// エイリアスとしてgetPeakをエクスポート\nexport { getPeakAmplitude as getPeak };\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length < 2) {\n    return 0;\n  }\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = ensureValidSample(channelData[i - 1]);\n    const current = ensureValidSample(channelData[i]);\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number; // nullを許容しない設計\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  const channelData = getChannelData(audio, channel);\n\n  // 修正2.3: 極端なフレーム数指定時の不具合対応\n  // audio.length が0の場合は frameCount も0にする\n  const desiredFrameCount = Math.ceil(audio.duration * framesPerSecond);\n  const maxPossibleFrameCount = audio.length > 0 ? audio.length : desiredFrameCount > 0 ? 1 : 0;\n  const frameCount = Math.min(desiredFrameCount, maxPossibleFrameCount);\n\n  const samplesPerFrame = frameCount > 0 ? Math.max(1, Math.floor(audio.length / frameCount)) : 0;\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム長が0または負の場合の処理\n    if (endSample <= startSample) {\n      // 最後の有効な振幅値を使用、または0\n      const lastAmplitude =\n        waveform.length > 0\n          ? safeArrayAccess(waveform, waveform.length - 1, { time: 0, amplitude: 0 }).amplitude\n          : 0;\n\n      waveform.push({\n        time: (startSample + samplesPerFrame / 2) / audio.sampleRate,\n        amplitude: lastAmplitude\n      });\n      continue;\n    }\n\n    // フレームデータの処理\n    const frameData = channelData.subarray(startSample, endSample); // sliceより効率的\n\n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n    waveform.push({ time, amplitude });\n\n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = ensureValidSample(frameData[i]);\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(ensureValidSample(frameData[i]));\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(ensureValidSample(frameData[i]));\n  }\n  return sum / frameData.length;\n}\n","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<void>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n// WebFFT型定義\ninterface WebFFTInstance {\n  fft(input: Float32Array): Float32Array;\n  profile(): Promise<unknown>;\n  dispose(): void;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: WebFFTInstance | null = null;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {}\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const webfftModule = await import('webfft');\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      const WebFFTConstructor = webfftModule.default as any;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      this.fftInstance = new WebFFTConstructor(this.size) as WebFFTInstance;\n\n      if (this.enableProfiling && this.fftInstance?.profile) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<void> {\n    if (!this.fftInstance || !this.fftInstance.profile) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    await this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance && this.fftInstance.dispose) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * 効率的なネイティブFFTプロバイダー（Cooley-Tukey実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  private bitReversalTable!: Uint32Array;\n  private twiddleFactorsReal!: Float32Array;\n  private twiddleFactorsImag!: Float32Array;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError('INVALID_INPUT', 'FFTサイズは2の冪である必要があります');\n    }\n    this.precomputeTables();\n  }\n\n  get name(): string {\n    return 'Native FFT (Cooley-Tukey)';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  private precomputeTables(): void {\n    // ビット反転テーブルの事前計算\n    this.bitReversalTable = new Uint32Array(this.size);\n    const bits = Math.log2(this.size);\n    for (let i = 0; i < this.size; i++) {\n      let reversed = 0;\n      for (let j = 0; j < bits; j++) {\n        reversed = (reversed << 1) | ((i >> j) & 1);\n      }\n      this.bitReversalTable[i] = reversed;\n    }\n\n    // Twiddle factorsの事前計算\n    const halfSize = this.size / 2;\n    this.twiddleFactorsReal = new Float32Array(halfSize);\n    this.twiddleFactorsImag = new Float32Array(halfSize);\n    for (let i = 0; i < halfSize; i++) {\n      const angle = (-2 * Math.PI * i) / this.size;\n      this.twiddleFactorsReal[i] = Math.cos(angle);\n      this.twiddleFactorsImag[i] = Math.sin(angle);\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // 複素数配列の初期化（ビット反転順）\n    const real = new Float32Array(this.size);\n    const imag = new Float32Array(this.size);\n\n    for (let i = 0; i < this.size; i++) {\n      const reversedIndex = this.bitReversalTable[i];\n      if (reversedIndex !== undefined) {\n        real[reversedIndex] = input[i] || 0;\n        imag[reversedIndex] = 0;\n      }\n    }\n\n    // Cooley-Tukey FFTアルゴリズム\n    for (let stage = 1; stage < this.size; stage *= 2) {\n      const stageSize = stage * 2;\n      const twiddleStep = this.size / stageSize;\n\n      for (let k = 0; k < this.size; k += stageSize) {\n        for (let j = 0; j < stage; j++) {\n          const twiddleIndex = j * twiddleStep;\n          const wr = this.twiddleFactorsReal[twiddleIndex] || 0;\n          const wi = this.twiddleFactorsImag[twiddleIndex] || 0;\n\n          const evenIndex = k + j;\n          const oddIndex = k + j + stage;\n\n          const evenReal = real[evenIndex] || 0;\n          const evenImag = imag[evenIndex] || 0;\n          const oddReal = real[oddIndex] || 0;\n          const oddImag = imag[oddIndex] || 0;\n\n          const tempReal = oddReal * wr - oddImag * wi;\n          const tempImag = oddReal * wi + oddImag * wr;\n\n          real[evenIndex] = evenReal + tempReal;\n          imag[evenIndex] = evenImag + tempImag;\n          real[oddIndex] = evenReal - tempReal;\n          imag[oddIndex] = evenImag - tempImag;\n        }\n      }\n    }\n\n    // 結果の構築\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < this.size; i++) {\n      complex[i * 2] = real[i] || 0;\n      complex[i * 2 + 1] = imag[i] || 0;\n\n      if (i <= this.size / 2) {\n        const realPart = real[i] || 0;\n        const imagPart = imag[i] || 0;\n        magnitude[i] = Math.sqrt(realPart * realPart + imagPart * imagPart);\n        phase[i] = Math.atan2(imagPart, realPart);\n        frequencies[i] = (i * this.sampleRate) / this.size;\n      }\n    }\n\n    return { complex, magnitude, phase, frequencies };\n  }\n\n  dispose(): void {\n    // メモリの明示的な解放（必要に応じて）\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft': {\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider.initializeWebFFT();\n        return provider;\n      }\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default: {\n        const exhaustiveCheck: never = config.type;\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${String(exhaustiveCheck)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { FFTProviderFactory, type FFTProviderType, type FFTResult } from '../core/fft-provider.js';\n\n/**\n * FFT分析のオプション\n */\nexport interface FFTOptions {\n  /** FFTサイズ（デフォルト: 2048、2の累乗である必要があります） */\n  fftSize?: number;\n  /** ウィンドウ関数（デフォルト: 'hann'） */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** オーバーラップ率（デフォルト: 0.5） */\n  overlap?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** FFTプロバイダー（デフォルト: 'webfft'） */\n  provider?: FFTProviderType;\n  /** プロファイリングを有効にする（WebFFTのみ） */\n  enableProfiling?: boolean;\n}\n\n/**\n * スペクトラム解析のオプション\n */\nexport interface SpectrumOptions extends FFTOptions {\n  /** 最小周波数（Hz、デフォルト: 0） */\n  minFrequency?: number;\n  /** 最大周波数（Hz、デフォルト: ナイキスト周波数） */\n  maxFrequency?: number;\n  /** dB表示かどうか（デフォルト: true） */\n  decibels?: boolean;\n  /** 時間フレーム数（スペクトログラム用、デフォルト: 100） */\n  timeFrames?: number;\n}\n\n/**\n * スペクトログラムデータ\n */\nexport interface SpectrogramData {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** 周波数軸（Hz） */\n  frequencies: Float32Array;\n  /** 強度データ（時間 x 周波数） */\n  intensities: Float32Array[];\n  /** フレーム数 */\n  timeFrames: number;\n  /** 周波数ビン数 */\n  frequencyBins: number;\n}\n\n/**\n * FFT分析結果\n */\nexport interface FFTAnalysisResult extends FFTResult {\n  /** FFTサイズ */\n  fftSize: number;\n  /** 使用されたウィンドウ関数 */\n  windowFunction: string;\n  /** プロバイダー名 */\n  providerName: string;\n}\n\n/**\n * スペクトラム解析結果\n */\nexport interface SpectrumAnalysisResult {\n  /** 周波数（Hz） */\n  frequencies: Float32Array;\n  /** 強度 */\n  magnitudes: Float32Array;\n  /** dB値（decielsオプションがtrueの場合） */\n  decibels?: Float32Array;\n  /** スペクトログラム（timeFrames > 1の場合） */\n  spectrogram?: SpectrogramData;\n}\n\n/**\n * ウィンドウ関数を適用\n */\nfunction applyWindow(data: Float32Array, windowType: string): Float32Array {\n  const windowed = new Float32Array(data.length);\n  const N = data.length;\n\n  for (let i = 0; i < N; i++) {\n    let windowValue = 1;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n        break;\n      case 'blackman':\n        windowValue =\n          0.42 -\n          0.5 * Math.cos((2 * Math.PI * i) / (N - 1)) +\n          0.08 * Math.cos((4 * Math.PI * i) / (N - 1));\n        break;\n      case 'none':\n      default:\n        windowValue = 1;\n        break;\n    }\n\n    windowed[i] = (data[i] || 0) * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < -1 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `Invalid channel number: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * FFT分析を行う\n *\n * @param audio - 音声データ\n * @param options - FFTオプション\n * @returns FFT結果\n */\nexport async function getFFT(\n  audio: AudioData,\n  options: FFTOptions = {}\n): Promise<FFTAnalysisResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    provider = 'webfft',\n    enableProfiling = false\n  } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // FFTサイズが入力より大きい場合、ゼロパディング\n  let inputData: Float32Array;\n  if (channelData.length < fftSize) {\n    inputData = new Float32Array(fftSize);\n    inputData.set(channelData);\n  } else {\n    inputData = channelData.slice(0, fftSize);\n  }\n\n  // ウィンドウ関数を適用\n  const windowedData = applyWindow(inputData, windowFunction);\n\n  // FFTプロバイダーを作成\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: provider,\n    fftSize,\n    sampleRate: audio.sampleRate,\n    enableProfiling\n  });\n\n  try {\n    // FFTを実行\n    const result = fftProvider.fft(windowedData);\n\n    return {\n      ...result,\n      fftSize,\n      windowFunction,\n      providerName: fftProvider.name\n    };\n  } finally {\n    // リソースを解放\n    fftProvider.dispose();\n  }\n}\n\n/**\n * スペクトラム解析を行う\n *\n * @param audio - 音声データ\n * @param options - スペクトラムオプション\n * @returns スペクトラム解析結果\n */\nexport async function getSpectrum(\n  audio: AudioData,\n  options: SpectrumOptions = {}\n): Promise<SpectrumAnalysisResult> {\n  const {\n    fftSize = 2048,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    decibels = true,\n    timeFrames = 1,\n    overlap = 0.5,\n    ...fftOptions\n  } = options;\n\n  const channelData = getChannelData(audio, options.channel || 0);\n\n  if (timeFrames === 1) {\n    // 単一フレームのスペクトラム解析\n    const fftResult = await getFFT(audio, { ...fftOptions, fftSize });\n\n    // 周波数範囲をフィルタリング\n    const filteredResult = filterFrequencyRange(fftResult, minFrequency, maxFrequency);\n\n    const result: SpectrumAnalysisResult = {\n      frequencies: filteredResult.frequencies,\n      magnitudes: filteredResult.magnitude\n    };\n\n    if (decibels) {\n      result.decibels = magnitudeToDecibels(filteredResult.magnitude);\n    }\n\n    return result;\n  } else {\n    // スペクトログラム解析\n    const spectrogram = await computeSpectrogram(\n      channelData,\n      audio.sampleRate,\n      fftSize,\n      timeFrames,\n      overlap,\n      { ...fftOptions, minFrequency, maxFrequency, decibels }\n    );\n\n    return {\n      frequencies: spectrogram.frequencies,\n      magnitudes: new Float32Array(), // スペクトログラムでは個別のmagnitudesは空\n      spectrogram\n    };\n  }\n}\n\n/**\n * 周波数範囲をフィルタリング\n */\nfunction filterFrequencyRange(fftResult: FFTResult, minFreq: number, maxFreq: number): FFTResult {\n  const { frequencies, magnitude, phase, complex } = fftResult;\n\n  const startIndex = frequencies.findIndex((f) => f >= minFreq);\n  const endIndex = frequencies.findIndex((f) => f > maxFreq);\n  const actualEndIndex = endIndex === -1 ? frequencies.length : endIndex;\n\n  return {\n    frequencies: frequencies.slice(startIndex, actualEndIndex),\n    magnitude: magnitude.slice(startIndex, actualEndIndex),\n    phase: phase.slice(startIndex, actualEndIndex),\n    complex: complex.slice(startIndex * 2, actualEndIndex * 2)\n  };\n}\n\n/**\n * 振幅をdBに変換\n */\nfunction magnitudeToDecibels(magnitude: Float32Array): Float32Array {\n  const decibels = new Float32Array(magnitude.length);\n  for (let i = 0; i < magnitude.length; i++) {\n    const mag = magnitude[i] || 0;\n    decibels[i] = mag > 0 ? 20 * Math.log10(mag) : -Infinity;\n  }\n  return decibels;\n}\n\n/**\n * スペクトログラム計算のオプション\n */\ninterface SpectrogramOptions {\n  provider?: FFTProviderType;\n  enableProfiling?: boolean;\n  windowFunction?: string;\n  minFrequency?: number;\n  maxFrequency?: number;\n  decibels?: boolean;\n}\n\n/**\n * スペクトログラムを計算\n */\nasync function computeSpectrogram(\n  data: Float32Array,\n  sampleRate: number,\n  fftSize: number,\n  timeFrames: number,\n  overlap: number,\n  options: SpectrogramOptions\n): Promise<SpectrogramData> {\n  const hopSize = Math.floor(fftSize * (1 - overlap));\n\n  // 修正2.2: 短音声データ処理時のフレーム数不足対応\n  let numPossibleFrames;\n  if (data.length === 0) {\n    numPossibleFrames = 0;\n  } else if (data.length < fftSize) {\n    // data.length > 0 かつ data.length < fftSize の場合、1フレームとして処理\n    numPossibleFrames = 1;\n  } else {\n    // data.length >= fftSize の場合\n    numPossibleFrames = Math.floor((data.length - fftSize) / hopSize) + 1;\n  }\n  const actualFrames = Math.min(timeFrames, numPossibleFrames);\n\n  const times = new Float32Array(actualFrames);\n  const intensities: Float32Array[] = [];\n  let frequencies: Float32Array = new Float32Array();\n  let filteredFrequencies: Float32Array = new Float32Array();\n  let frequencyStartIndex = 0;\n  let frequencyEndIndex = 0;\n\n  // FFTプロバイダーを作成（一度だけ）\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: options.provider || 'webfft',\n    fftSize,\n    sampleRate,\n    enableProfiling: options.enableProfiling || false\n  });\n\n  try {\n    for (let frame = 0; frame < actualFrames; frame++) {\n      const startSample = frame * hopSize;\n\n      // フレームデータを抽出\n      const frameData = new Float32Array(fftSize);\n      for (let i = 0; i < fftSize; i++) {\n        frameData[i] = startSample + i < data.length ? data[startSample + i] || 0 : 0;\n      }\n\n      // ウィンドウ関数を適用\n      const windowedData = applyWindow(frameData, options.windowFunction || 'hann');\n\n      // FFTを実行\n      const fftResult = fftProvider.fft(windowedData);\n\n      // 修正2.1: 最初のフレームで周波数範囲フィルタリングを設定\n      if (frame === 0) {\n        frequencies = fftResult.frequencies;\n\n        // 周波数フィルタリングのインデックス範囲を決定\n        const minFreq = options.minFrequency || 0;\n        const maxFreq = options.maxFrequency || sampleRate / 2;\n\n        frequencyStartIndex = frequencies.findIndex((f) => f >= minFreq);\n        if (frequencyStartIndex === -1) frequencyStartIndex = 0;\n\n        const tempEndIndex = frequencies.findIndex((f) => f > maxFreq);\n        frequencyEndIndex = tempEndIndex === -1 ? frequencies.length : tempEndIndex;\n\n        // フィルタリングされた周波数軸を作成\n        filteredFrequencies = frequencies.slice(frequencyStartIndex, frequencyEndIndex);\n      }\n\n      // 強度データを保存（周波数範囲フィルタリング適用）\n      const magnitude = fftResult.magnitude;\n      const filteredMagnitude = magnitude.slice(frequencyStartIndex, frequencyEndIndex);\n      const frameIntensity = options.decibels\n        ? magnitudeToDecibels(filteredMagnitude)\n        : filteredMagnitude;\n      intensities.push(frameIntensity);\n\n      // 時間位置を計算\n      times[frame] = (startSample + fftSize / 2) / sampleRate;\n    }\n  } finally {\n    fftProvider.dispose();\n  }\n\n  return {\n    times,\n    frequencies: filteredFrequencies, // フィルタリングされた周波数軸を返す\n    intensities,\n    timeFrames: actualFrames,\n    frequencyBins: filteredFrequencies.length\n  };\n}\n","import { AudioData, AudioInspectError } from '../types';\nimport { ensureValidSample } from '../core/utils';\nimport { getFFT } from './frequency';\n\n/**\n * スペクトル特徴量のオプション\n */\nexport interface SpectralFeaturesOptions {\n  /** FFTサイズ */\n  fftSize?: number;\n  /** 窓関数 */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** 解析するチャンネル */\n  channel?: number;\n  /** 最小周波数 */\n  minFrequency?: number;\n  /** 最大周波数 */\n  maxFrequency?: number;\n  /** スペクトルロールオフの閾値（0-1） */\n  rolloffThreshold?: number;\n}\n\n/**\n * スペクトル特徴量の結果\n */\nexport interface SpectralFeaturesResult {\n  /** スペクトル重心（Hz） */\n  spectralCentroid: number;\n  /** スペクトル帯域幅（Hz） */\n  spectralBandwidth: number;\n  /** スペクトルロールオフ（Hz） */\n  spectralRolloff: number;\n  /** スペクトルフラットネス（0-1） */\n  spectralFlatness: number;\n  /** スペクトルフラックス */\n  spectralFlux?: number;\n  /** ゼロ交差率 */\n  zeroCrossingRate: number;\n  /** 使用された周波数範囲 */\n  frequencyRange: { min: number; max: number };\n}\n\n/**\n * 時系列スペクトル特徴量のオプション\n */\nexport interface TimeVaryingSpectralOptions extends SpectralFeaturesOptions {\n  /** フレームサイズ */\n  frameSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** フレーム数（指定しない場合は全体を解析） */\n  numFrames?: number;\n}\n\n/**\n * 時系列スペクトル特徴量の結果\n */\nexport interface TimeVaryingSpectralResult {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** スペクトル重心の時系列 */\n  spectralCentroid: Float32Array;\n  /** スペクトル帯域幅の時系列 */\n  spectralBandwidth: Float32Array;\n  /** スペクトルロールオフの時系列 */\n  spectralRolloff: Float32Array;\n  /** スペクトルフラットネスの時系列 */\n  spectralFlatness: Float32Array;\n  /** スペクトルフラックスの時系列 */\n  spectralFlux: Float32Array;\n  /** ゼロ交差率の時系列 */\n  zeroCrossingRate: Float32Array;\n  /** フレーム情報 */\n  frameInfo: {\n    frameSize: number;\n    hopSize: number;\n    numFrames: number;\n  };\n}\n\n/**\n * スペクトル重心を計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトル重心（Hz）\n */\nfunction calculateSpectralCentroid(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  minFreq: number,\n  maxFreq: number\n): number {\n  let weightedSum = 0;\n  let magnitudeSum = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      weightedSum += freq * mag;\n      magnitudeSum += mag;\n    }\n  }\n\n  return magnitudeSum > 1e-10 ? weightedSum / magnitudeSum : 0;\n}\n\n/**\n * スペクトル帯域幅を計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param centroid スペクトル重心\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトル帯域幅（Hz）\n */\nfunction calculateSpectralBandwidth(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  centroid: number,\n  minFreq: number,\n  maxFreq: number\n): number {\n  let weightedVarianceSum = 0;\n  let magnitudeSum = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      const deviation = freq - centroid;\n      weightedVarianceSum += deviation * deviation * mag;\n      magnitudeSum += mag;\n    }\n  }\n\n  return magnitudeSum > 1e-10 ? Math.sqrt(weightedVarianceSum / magnitudeSum) : 0;\n}\n\n/**\n * スペクトルロールオフを計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param threshold 閾値（0-1）\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトルロールオフ（Hz）\n */\nfunction calculateSpectralRolloff(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  threshold: number,\n  minFreq: number,\n  maxFreq: number\n): number {\n  // 指定範囲内の総エネルギーを計算\n  let totalEnergy = 0;\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      totalEnergy += mag * mag;\n    }\n  }\n\n  const targetEnergy = totalEnergy * threshold;\n  let cumulativeEnergy = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      cumulativeEnergy += mag * mag;\n      if (cumulativeEnergy >= targetEnergy) {\n        return freq;\n      }\n    }\n  }\n\n  return maxFreq;\n}\n\n/**\n * スペクトルフラットネスを計算\n * @param magnitude スペクトル振幅\n * @param minIndex 最小インデックス\n * @param maxIndex 最大インデックス\n * @returns スペクトルフラットネス（0-1）\n */\nfunction calculateSpectralFlatness(\n  magnitude: Float32Array,\n  minIndex: number,\n  maxIndex: number\n): number {\n  let geometricMean = 0;\n  let arithmeticMean = 0;\n  let count = 0;\n\n  for (let i = minIndex; i <= maxIndex && i < magnitude.length; i++) {\n    const mag = magnitude[i];\n    if (mag !== undefined) {\n      const safeMag = Math.max(mag, 1e-10); // ゼロ除算を防ぐ\n      geometricMean += Math.log(safeMag);\n      arithmeticMean += safeMag;\n      count++;\n    }\n  }\n\n  if (count === 0) return 0;\n\n  geometricMean = Math.exp(geometricMean / count);\n  arithmeticMean = arithmeticMean / count;\n\n  return arithmeticMean > 1e-10 ? geometricMean / arithmeticMean : 0;\n}\n\n/**\n * ゼロ交差率を計算\n * @param samples 音声サンプル\n * @returns ゼロ交差率\n */\nfunction calculateZeroCrossingRate(samples: Float32Array): number {\n  if (samples.length < 2) return 0;\n\n  let crossings = 0;\n  for (let i = 1; i < samples.length; i++) {\n    const prev = ensureValidSample(samples[i - 1]);\n    const curr = ensureValidSample(samples[i]);\n\n    if ((prev >= 0 && curr < 0) || (prev < 0 && curr >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (samples.length - 1);\n}\n\n/**\n * スペクトルフラックスを計算\n * @param currentMagnitude 現在のフレームのスペクトル振幅\n * @param previousMagnitude 前のフレームのスペクトル振幅\n * @returns スペクトルフラックス\n */\nfunction calculateSpectralFlux(\n  currentMagnitude: Float32Array,\n  previousMagnitude?: Float32Array\n): number {\n  if (!previousMagnitude) return 0;\n\n  let flux = 0;\n  const length = Math.min(currentMagnitude.length, previousMagnitude.length);\n\n  for (let i = 0; i < length; i++) {\n    const current = currentMagnitude[i];\n    const previous = previousMagnitude[i];\n    if (current !== undefined && previous !== undefined) {\n      const diff = current - previous;\n      flux += diff * diff;\n    }\n  }\n\n  return Math.sqrt(flux / length);\n}\n\n/**\n * 単一フレームのスペクトル特徴量を計算\n * @param audio 音声データ\n * @param options オプション\n * @returns スペクトル特徴量\n */\nexport async function getSpectralFeatures(\n  audio: AudioData,\n  options: SpectralFeaturesOptions = {}\n): Promise<SpectralFeaturesResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    rolloffThreshold = 0.85\n  } = options;\n\n  if (channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `無効なチャンネル番号: ${channel}`);\n  }\n\n  // FFT解析\n  const fftResult = await getFFT(audio, {\n    fftSize,\n    windowFunction,\n    channel\n  });\n\n  // 周波数範囲のインデックスを計算\n  const minIndex = Math.max(0, Math.floor((minFrequency * fftSize) / audio.sampleRate));\n  const maxIndex = Math.min(\n    fftResult.frequencies.length - 1,\n    Math.floor((maxFrequency * fftSize) / audio.sampleRate)\n  );\n\n  // スペクトル重心\n  const spectralCentroid = calculateSpectralCentroid(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトル帯域幅\n  const spectralBandwidth = calculateSpectralBandwidth(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    spectralCentroid,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトルロールオフ\n  const spectralRolloff = calculateSpectralRolloff(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    rolloffThreshold,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトルフラットネス\n  const spectralFlatness = calculateSpectralFlatness(fftResult.magnitude, minIndex, maxIndex);\n\n  // ゼロ交差率\n  const samples = audio.channelData[channel];\n  if (!samples) {\n    throw new AudioInspectError('INVALID_INPUT', `チャンネル ${channel} のデータが存在しません`);\n  }\n  const zeroCrossingRate = calculateZeroCrossingRate(samples);\n\n  return {\n    spectralCentroid,\n    spectralBandwidth,\n    spectralRolloff,\n    spectralFlatness,\n    zeroCrossingRate,\n    frequencyRange: {\n      min: minFrequency,\n      max: maxFrequency\n    }\n  };\n}\n\n/**\n * 時系列スペクトル特徴量を計算\n * @param audio 音声データ\n * @param options オプション\n * @returns 時系列スペクトル特徴量\n */\nexport async function getTimeVaryingSpectralFeatures(\n  audio: AudioData,\n  options: TimeVaryingSpectralOptions = {}\n): Promise<TimeVaryingSpectralResult> {\n  const {\n    frameSize = 2048,\n    hopSize = frameSize / 2,\n    fftSize = frameSize,\n    windowFunction = 'hann',\n    channel = 0,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    rolloffThreshold = 0.85,\n    numFrames\n  } = options;\n\n  if (channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `無効なチャンネル番号: ${channel}`);\n  }\n\n  const samples = audio.channelData[channel];\n  if (!samples) {\n    throw new AudioInspectError('INVALID_INPUT', `チャンネル ${channel} のデータが存在しません`);\n  }\n\n  const totalFrames = numFrames || Math.floor((samples.length - frameSize) / hopSize) + 1;\n\n  if (totalFrames <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'フレーム数が不正です');\n  }\n\n  // 結果配列の初期化\n  const times = new Float32Array(totalFrames);\n  const spectralCentroid = new Float32Array(totalFrames);\n  const spectralBandwidth = new Float32Array(totalFrames);\n  const spectralRolloff = new Float32Array(totalFrames);\n  const spectralFlatness = new Float32Array(totalFrames);\n  const spectralFlux = new Float32Array(totalFrames);\n  const zeroCrossingRate = new Float32Array(totalFrames);\n\n  let previousMagnitude: Float32Array | undefined;\n\n  // フレームごとの解析\n  for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {\n    const startSample = frameIndex * hopSize;\n    const endSample = Math.min(startSample + frameSize, samples.length);\n\n    // 時間位置\n    times[frameIndex] = startSample / audio.sampleRate;\n\n    // フレームデータの抽出\n    const frameData = samples.subarray(startSample, endSample);\n\n    // 短いフレームの場合はゼロパディング\n    const paddedFrame = new Float32Array(frameSize);\n    paddedFrame.set(frameData);\n\n    // フレーム用の音声データを作成\n    const frameAudio: AudioData = {\n      channelData: [paddedFrame],\n      sampleRate: audio.sampleRate,\n      numberOfChannels: 1,\n      length: frameSize,\n      duration: frameSize / audio.sampleRate\n    };\n\n    // スペクトル特徴量を計算\n    const features = await getSpectralFeatures(frameAudio, {\n      fftSize,\n      windowFunction,\n      channel: 0,\n      minFrequency,\n      maxFrequency,\n      rolloffThreshold\n    });\n\n    spectralCentroid[frameIndex] = features.spectralCentroid;\n    spectralBandwidth[frameIndex] = features.spectralBandwidth;\n    spectralRolloff[frameIndex] = features.spectralRolloff;\n    spectralFlatness[frameIndex] = features.spectralFlatness;\n    zeroCrossingRate[frameIndex] = features.zeroCrossingRate;\n\n    // スペクトルフラックスの計算（前フレームとの比較）\n    const fftResult = await getFFT(frameAudio, { fftSize, windowFunction, channel: 0 });\n    spectralFlux[frameIndex] = calculateSpectralFlux(fftResult.magnitude, previousMagnitude);\n    previousMagnitude = new Float32Array(fftResult.magnitude);\n  }\n\n  return {\n    times,\n    spectralCentroid,\n    spectralBandwidth,\n    spectralRolloff,\n    spectralFlatness,\n    spectralFlux,\n    zeroCrossingRate,\n    frameInfo: {\n      frameSize,\n      hopSize,\n      numFrames: totalFrames\n    }\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\n\nexport interface EnergyOptions {\n  frameSize?: number;\n  hopSize?: number;\n  channel?: number;\n  normalized?: boolean;\n  windowFunction?: 'rectangular' | 'hann' | 'hamming'; // エネルギー計算用の窓関数\n}\n\nexport interface EnergyResult {\n  times: Float32Array;\n  energies: Float32Array;\n  totalEnergy: number;\n  statistics: {\n    mean: number;\n    std: number;\n    max: number;\n    min: number;\n  };\n}\n\n// 窓関数の適用（エネルギー計算用）\nfunction applyEnergyWindow(\n  data: Float32Array,\n  windowType: string,\n  startIdx: number,\n  length: number\n): Float32Array {\n  const windowed = new Float32Array(length);\n\n  for (let i = 0; i < length && startIdx + i < data.length; i++) {\n    let windowValue = 1.0;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (length - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (length - 1));\n        break;\n      case 'rectangular':\n      default:\n        windowValue = 1.0;\n    }\n\n    const sample = ensureValidSample(data[startIdx + i]);\n    windowed[i] = sample * windowValue;\n  }\n\n  return windowed;\n}\n\nexport function getEnergy(audio: AudioData, options: EnergyOptions = {}): EnergyResult {\n  const {\n    frameSize = Math.floor(audio.sampleRate * 0.025), // 25ms\n    hopSize = Math.floor(audio.sampleRate * 0.01), // 10ms\n    channel = 0,\n    normalized = false,\n    windowFunction = 'rectangular'\n  } = options;\n\n  // パラメータの検証\n  if (frameSize <= 0 || !Number.isInteger(frameSize)) {\n    throw new AudioInspectError('INVALID_INPUT', 'frameSizeは正の整数である必要があります');\n  }\n\n  if (hopSize <= 0 || !Number.isInteger(hopSize)) {\n    throw new AudioInspectError('INVALID_INPUT', 'hopSizeは正の整数である必要があります');\n  }\n\n  if (hopSize > frameSize) {\n    console.warn(\n      '[audio-inspect] hopSizeがframeSizeより大きいため、フレーム間にギャップが生じます'\n    );\n  }\n\n  const channelData = getChannelData(audio, channel);\n  const dataLength = channelData.length;\n\n  if (dataLength === 0) {\n    return {\n      times: new Float32Array(0),\n      energies: new Float32Array(0),\n      totalEnergy: 0,\n      statistics: { mean: 0, std: 0, max: 0, min: 0 }\n    };\n  }\n\n  // フレーム数の計算\n  const frameCount = Math.max(0, Math.floor((dataLength - frameSize) / hopSize) + 1);\n\n  if (frameCount === 0) {\n    // データが1フレーム分に満たない場合\n    const energy = calculateFrameEnergy(channelData, 0, dataLength, windowFunction);\n    return {\n      times: new Float32Array([dataLength / 2 / audio.sampleRate]),\n      energies: new Float32Array([energy]),\n      totalEnergy: energy,\n      statistics: { mean: energy, std: 0, max: energy, min: energy }\n    };\n  }\n\n  const times = new Float32Array(frameCount);\n  const energies = new Float32Array(frameCount);\n  let totalEnergy = 0;\n  let maxEnergy = -Infinity;\n  let minEnergy = Infinity;\n\n  // 各フレームのエネルギー計算\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSize;\n    const windowedFrame = applyEnergyWindow(channelData, windowFunction, start, frameSize);\n\n    let frameEnergy = 0;\n    for (let j = 0; j < windowedFrame.length; j++) {\n      const sample = windowedFrame[j];\n      if (sample !== undefined) {\n        frameEnergy += sample * sample;\n      }\n    }\n\n    times[i] = (start + frameSize / 2) / audio.sampleRate;\n    energies[i] = frameEnergy;\n    totalEnergy += frameEnergy;\n\n    maxEnergy = Math.max(maxEnergy, frameEnergy);\n    minEnergy = Math.min(minEnergy, frameEnergy);\n  }\n\n  // 統計情報の計算\n  const meanEnergy = totalEnergy / frameCount;\n  let varianceSum = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const energy = energies[i];\n    if (energy !== undefined) {\n      const diff = energy - meanEnergy;\n      varianceSum += diff * diff;\n    }\n  }\n\n  const stdEnergy = Math.sqrt(varianceSum / frameCount);\n\n  // 正規化（オプション）\n  if (normalized && totalEnergy > 1e-10) {\n    for (let i = 0; i < energies.length; i++) {\n      const currentEnergy = energies[i];\n      if (currentEnergy !== undefined) {\n        energies[i] = currentEnergy / totalEnergy;\n      }\n    }\n\n    return {\n      times,\n      energies,\n      totalEnergy: 1.0,\n      statistics: {\n        mean: meanEnergy / totalEnergy,\n        std: stdEnergy / totalEnergy,\n        max: maxEnergy / totalEnergy,\n        min: minEnergy / totalEnergy\n      }\n    };\n  }\n\n  return {\n    times,\n    energies,\n    totalEnergy,\n    statistics: {\n      mean: meanEnergy,\n      std: stdEnergy,\n      max: maxEnergy,\n      min: minEnergy\n    }\n  };\n}\n\n// ヘルパー関数\nfunction calculateFrameEnergy(\n  data: Float32Array,\n  start: number,\n  length: number,\n  windowFunction: string\n): number {\n  const windowed = applyEnergyWindow(data, windowFunction, start, length);\n  let energy = 0;\n  for (const sample of windowed) {\n    energy += sample * sample;\n  }\n  return energy;\n}\n","import { AudioData, AudioInspectError, AmplitudeOptions } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\nimport { getRMS, getPeakAmplitude } from './time.js';\n\nexport interface CrestFactorOptions {\n  channel?: number;\n  windowSize?: number; // 窓サイズ（秒）\n  hopSize?: number; // ホップサイズ（秒）\n  method?: 'simple' | 'weighted'; // 重み付きクレストファクター\n}\n\nexport interface CrestFactorResult {\n  crestFactor: number; // 全体のクレストファクター (dB)\n  crestFactorLinear: number; // 線形スケールのクレストファクター\n  peak: number; // ピーク値（線形）\n  rms: number; // RMS値（線形）\n  timeVarying?:\n    | {\n        times: Float32Array;\n        values: Float32Array; // dB\n        valuesLinear: Float32Array; // 線形\n        peaks: Float32Array;\n        rmsValues: Float32Array;\n      }\n    | undefined;\n}\n\nfunction calculateFrameCrestFactor(\n  frameData: Float32Array,\n  method: 'simple' | 'weighted' = 'simple'\n): { peak: number; rms: number; cfDb: number; cfLinear: number } {\n  if (frameData.length === 0) {\n    return { peak: 0, rms: 0, cfDb: -Infinity, cfLinear: 0 };\n  }\n\n  let processedData = frameData;\n\n  // 重み付き処理（オプション）\n  if (method === 'weighted') {\n    // A-weightingの簡易実装\n    // 実際にはIIRフィルタで実装すべき\n    processedData = frameData; // プレースホルダー\n  }\n\n  let peakVal = 0;\n  let sumOfSquares = 0;\n  let validSamples = 0;\n\n  for (let i = 0; i < processedData.length; i++) {\n    const sample = ensureValidSample(processedData[i]);\n    const absSample = Math.abs(sample);\n\n    peakVal = Math.max(peakVal, absSample);\n    sumOfSquares += sample * sample;\n    validSamples++;\n  }\n\n  if (validSamples === 0) {\n    return { peak: 0, rms: 0, cfDb: -Infinity, cfLinear: 0 };\n  }\n\n  const rmsVal = Math.sqrt(sumOfSquares / validSamples);\n\n  if (rmsVal < 1e-10) {\n    return { peak: peakVal, rms: rmsVal, cfDb: Infinity, cfLinear: Infinity };\n  }\n\n  const cfLinear = peakVal / rmsVal;\n  const cfDb = 20 * Math.log10(cfLinear);\n\n  return { peak: peakVal, rms: rmsVal, cfDb, cfLinear };\n}\n\nexport function getCrestFactor(\n  audio: AudioData,\n  options: CrestFactorOptions = {}\n): CrestFactorResult {\n  const { channel = 0, windowSize, hopSize, method = 'simple' } = options;\n\n  // 全体のクレストファクター計算\n  const amplitudeOpts: AmplitudeOptions = { channel, asDB: false };\n  const overallPeak = getPeakAmplitude(audio, amplitudeOpts);\n  const overallRms = getRMS(audio, amplitudeOpts);\n\n  const overallCfLinear = overallRms > 1e-10 ? overallPeak / overallRms : Infinity;\n  const overallCfDb = overallRms > 1e-10 ? 20 * Math.log10(overallCfLinear) : Infinity;\n\n  let timeVaryingResult: CrestFactorResult['timeVarying'] | undefined;\n\n  // 時変クレストファクター計算\n  if (typeof windowSize === 'number' && typeof hopSize === 'number') {\n    if (windowSize <= 0 || hopSize <= 0) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        'windowSizeとhopSizeは正の値である必要があります'\n      );\n    }\n\n    if (hopSize > windowSize) {\n      console.warn(\n        '[audio-inspect] hopSizeがwindowSizeより大きいため、分析窓間にギャップが生じます'\n      );\n    }\n\n    const windowSizeSamples = Math.floor(windowSize * audio.sampleRate);\n    const hopSizeSamples = Math.floor(hopSize * audio.sampleRate);\n\n    if (windowSizeSamples === 0 || hopSizeSamples === 0) {\n      throw new AudioInspectError('INVALID_INPUT', 'サンプルレートに対して窓サイズが小さすぎます');\n    }\n\n    const channelData = getChannelData(audio, channel);\n    const dataLength = channelData.length;\n\n    if (dataLength < windowSizeSamples) {\n      // データが1窓分に満たない場合\n      const result = calculateFrameCrestFactor(channelData, method);\n      timeVaryingResult = {\n        times: new Float32Array([audio.duration / 2]),\n        values: new Float32Array([result.cfDb]),\n        valuesLinear: new Float32Array([result.cfLinear]),\n        peaks: new Float32Array([result.peak]),\n        rmsValues: new Float32Array([result.rms])\n      };\n    } else {\n      const frameCount = Math.floor((dataLength - windowSizeSamples) / hopSizeSamples) + 1;\n      const times = new Float32Array(frameCount);\n      const values = new Float32Array(frameCount);\n      const valuesLinear = new Float32Array(frameCount);\n      const peaks = new Float32Array(frameCount);\n      const rmsValues = new Float32Array(frameCount);\n\n      for (let i = 0; i < frameCount; i++) {\n        const start = i * hopSizeSamples;\n        const end = Math.min(start + windowSizeSamples, dataLength);\n        const frameData = channelData.subarray(start, end);\n\n        const frameResult = calculateFrameCrestFactor(frameData, method);\n\n        times[i] = (start + windowSizeSamples / 2) / audio.sampleRate;\n        values[i] = frameResult.cfDb;\n        valuesLinear[i] = frameResult.cfLinear;\n        peaks[i] = frameResult.peak;\n        rmsValues[i] = frameResult.rms;\n      }\n\n      timeVaryingResult = { times, values, valuesLinear, peaks, rmsValues };\n    }\n  }\n\n  return {\n    crestFactor: overallCfDb,\n    crestFactorLinear: overallCfLinear,\n    peak: overallPeak,\n    rms: overallRms,\n    timeVarying: timeVaryingResult\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { getFFT } from './frequency.js';\nimport { ensureValidSample } from '../core/utils.js';\n\nexport interface StereoAnalysisOptions {\n  frameSize?: number; // 分析フレームサイズ（サンプル数）\n  hopSize?: number; // ホップサイズ（サンプル数）\n  calculatePhase?: boolean; // 位相解析を行うか\n  calculateITD?: boolean; // 両耳間時間差を計算するか\n  calculateILD?: boolean; // 両耳間レベル差を計算するか\n}\n\nexport interface StereoAnalysisResult {\n  correlation: number; // 相関係数 (-1 to 1)\n  coherence?: Float32Array; // 周波数別コヒーレンス\n  width: number; // ステレオ幅 (0 to 1)\n  widthFrequency?: Float32Array; // 周波数別ステレオ幅\n  balance: number; // L/R バランス (-1 to 1)\n  phaseDifference?: number; // 平均位相差（度）\n  phaseCorrelation?: number; // 位相相関 (-1 to 1)\n  midSideRatio: number; // Mid/Side エネルギー比 (dB)\n  itd?: number; // 両耳間時間差 (ms)\n  ild?: number; // 両耳間レベル差 (dB)\n  goniometer?: {\n    // ゴニオメーター用データ\n    x: Float32Array; // L-R (Side)\n    y: Float32Array; // L+R (Mid)\n  };\n}\n\n// クロス相関による遅延推定\nfunction estimateDelay(\n  left: Float32Array,\n  right: Float32Array,\n  maxDelaySamples: number = 44\n): number {\n  const len = Math.min(left.length, right.length);\n  let maxCorr = -Infinity;\n  let bestDelay = 0;\n\n  for (let delay = -maxDelaySamples; delay <= maxDelaySamples; delay++) {\n    let correlation = 0;\n    let count = 0;\n\n    for (let i = 0; i < len; i++) {\n      const leftIdx = i;\n      const rightIdx = i + delay;\n\n      if (rightIdx >= 0 && rightIdx < len) {\n        const leftSample = ensureValidSample(left[leftIdx]);\n        const rightSample = ensureValidSample(right[rightIdx]);\n        correlation += leftSample * rightSample;\n        count++;\n      }\n    }\n\n    if (count > 0) {\n      correlation /= count;\n      if (correlation > maxCorr) {\n        maxCorr = correlation;\n        bestDelay = delay;\n      }\n    }\n  }\n\n  return bestDelay;\n}\n\n// コヒーレンス計算\nasync function calculateCoherence(\n  left: Float32Array,\n  right: Float32Array,\n  fftSize: number,\n  sampleRate: number\n): Promise<Float32Array> {\n  const leftFFT = await getFFT(\n    {\n      channelData: [left],\n      sampleRate,\n      numberOfChannels: 1,\n      length: left.length,\n      duration: left.length / sampleRate\n    },\n    { fftSize }\n  );\n\n  const rightFFT = await getFFT(\n    {\n      channelData: [right],\n      sampleRate,\n      numberOfChannels: 1,\n      length: right.length,\n      duration: right.length / sampleRate\n    },\n    { fftSize }\n  );\n\n  const coherence = new Float32Array(leftFFT.magnitude.length);\n\n  for (let i = 0; i < coherence.length; i++) {\n    const leftMag = leftFFT.magnitude[i] || 0;\n    const rightMag = rightFFT.magnitude[i] || 0;\n    const leftPhase = leftFFT.phase[i] || 0;\n    const rightPhase = rightFFT.phase[i] || 0;\n\n    // クロススペクトル\n    const crossReal = leftMag * rightMag * Math.cos(leftPhase - rightPhase);\n    const crossImag = leftMag * rightMag * Math.sin(leftPhase - rightPhase);\n    const crossMag = Math.sqrt(crossReal * crossReal + crossImag * crossImag);\n\n    // コヒーレンス = |Pxy|^2 / (Pxx * Pyy)\n    const denominator = leftMag * leftMag * rightMag * rightMag;\n    coherence[i] = denominator > 1e-10 ? (crossMag * crossMag) / denominator : 0;\n  }\n\n  return coherence;\n}\n\n// 周波数別ステレオ幅\nfunction calculateFrequencyWidth(\n  leftMag: Float32Array,\n  rightMag: Float32Array,\n  leftPhase: Float32Array,\n  rightPhase: Float32Array\n): Float32Array {\n  const width = new Float32Array(leftMag.length);\n\n  for (let i = 0; i < width.length; i++) {\n    const lMag = leftMag[i] || 0;\n    const rMag = rightMag[i] || 0;\n    const lPhase = leftPhase[i] || 0;\n    const rPhase = rightPhase[i] || 0;\n    const phaseDiff = lPhase - rPhase;\n\n    // M/S変換\n    const midMag = Math.abs(lMag + rMag) / 2;\n    const sideMag = Math.abs(lMag - rMag) / 2;\n\n    // 位相差も考慮したステレオ幅\n    const phaseWidth = Math.abs(Math.sin(phaseDiff / 2));\n    const magWidth = sideMag / (midMag + sideMag + 1e-10);\n\n    width[i] = Math.max(magWidth, phaseWidth);\n  }\n\n  return width;\n}\n\nexport async function getStereoAnalysis(\n  audio: AudioData,\n  options: StereoAnalysisOptions = {}\n): Promise<StereoAnalysisResult> {\n  if (audio.numberOfChannels < 2) {\n    throw new AudioInspectError('INVALID_INPUT', 'ステレオ解析には2チャンネル以上の音声が必要です');\n  }\n\n  const {\n    frameSize = audio.length,\n    calculatePhase = true,\n    calculateITD = true,\n    calculateILD = true\n  } = options;\n\n  const left = audio.channelData[0];\n  const right = audio.channelData[1];\n\n  if (!left || !right) {\n    throw new AudioInspectError('INVALID_INPUT', 'L/Rチャンネルのデータが存在しません');\n  }\n\n  const len = Math.min(left.length, right.length);\n\n  if (len === 0) {\n    return {\n      correlation: 0,\n      width: 0,\n      balance: 0,\n      midSideRatio: 0\n    };\n  }\n\n  // 基本的な統計量の計算\n  let sumL = 0,\n    sumR = 0,\n    sumLR = 0,\n    sumL2 = 0,\n    sumR2 = 0;\n  let energyL = 0,\n    energyR = 0;\n\n  for (let i = 0; i < len; i++) {\n    const l = ensureValidSample(left[i]);\n    const r = ensureValidSample(right[i]);\n\n    sumL += l;\n    sumR += r;\n    sumLR += l * r;\n    sumL2 += l * l;\n    sumR2 += r * r;\n\n    energyL += l * l;\n    energyR += r * r;\n  }\n\n  // 相関係数\n  const meanL = sumL / len;\n  const meanR = sumR / len;\n  const covariance = sumLR / len - meanL * meanR;\n  const stdL = Math.sqrt(sumL2 / len - meanL * meanL);\n  const stdR = Math.sqrt(sumR2 / len - meanR * meanR);\n  const correlation = stdL > 1e-10 && stdR > 1e-10 ? covariance / (stdL * stdR) : 0;\n\n  // Mid/Side処理\n  const mid = new Float32Array(len);\n  const side = new Float32Array(len);\n  let energyMid = 0,\n    energySide = 0;\n\n  for (let i = 0; i < len; i++) {\n    const l = ensureValidSample(left[i]);\n    const r = ensureValidSample(right[i]);\n\n    mid[i] = (l + r) * 0.5;\n    side[i] = (l - r) * 0.5;\n\n    energyMid += (mid[i] ?? 0) * (mid[i] ?? 0);\n    energySide += (side[i] ?? 0) * (side[i] ?? 0);\n  }\n\n  // メトリクスの計算\n  const width = energyMid + energySide > 1e-10 ? energySide / (energyMid + energySide) : 0;\n\n  const balance = energyL + energyR > 1e-10 ? (energyR - energyL) / (energyL + energyR) : 0;\n\n  const midSideRatio = energySide > 1e-10 ? 10 * Math.log10(energyMid / energySide) : Infinity;\n\n  const result: StereoAnalysisResult = {\n    correlation,\n    width,\n    balance,\n    midSideRatio\n  };\n\n  // 位相解析（オプション）\n  if (calculatePhase && frameSize < audio.length) {\n    const fftSize = Math.pow(2, Math.ceil(Math.log2(frameSize)));\n\n    // コヒーレンス計算\n    result.coherence = await calculateCoherence(\n      left.subarray(0, frameSize),\n      right.subarray(0, frameSize),\n      fftSize,\n      audio.sampleRate\n    );\n\n    // 周波数別解析\n    const leftFFT = await getFFT(\n      {\n        channelData: [left.subarray(0, frameSize)],\n        sampleRate: audio.sampleRate,\n        numberOfChannels: 1,\n        length: frameSize,\n        duration: frameSize / audio.sampleRate\n      },\n      { fftSize }\n    );\n\n    const rightFFT = await getFFT(\n      {\n        channelData: [right.subarray(0, frameSize)],\n        sampleRate: audio.sampleRate,\n        numberOfChannels: 1,\n        length: frameSize,\n        duration: frameSize / audio.sampleRate\n      },\n      { fftSize }\n    );\n\n    // 周波数別ステレオ幅\n    result.widthFrequency = calculateFrequencyWidth(\n      leftFFT.magnitude,\n      rightFFT.magnitude,\n      leftFFT.phase,\n      rightFFT.phase\n    );\n\n    // 平均位相差\n    let phaseDiffSum = 0;\n    let weightSum = 0;\n\n    for (let i = 1; i < leftFFT.phase.length; i++) {\n      // DC成分を除外\n      const leftMag = leftFFT.magnitude[i] || 0;\n      const rightMag = rightFFT.magnitude[i] || 0;\n      const leftPhase = leftFFT.phase[i] || 0;\n      const rightPhase = rightFFT.phase[i] || 0;\n\n      const weight = leftMag * rightMag;\n      let phaseDiff = leftPhase - rightPhase;\n\n      // 位相差を -π から π の範囲に正規化\n      while (phaseDiff > Math.PI) phaseDiff -= 2 * Math.PI;\n      while (phaseDiff < -Math.PI) phaseDiff += 2 * Math.PI;\n\n      phaseDiffSum += phaseDiff * weight;\n      weightSum += weight;\n    }\n\n    result.phaseDifference = weightSum > 1e-10 ? ((phaseDiffSum / weightSum) * 180) / Math.PI : 0;\n  }\n\n  // ITD（両耳間時間差）計算（オプション）\n  if (calculateITD) {\n    const delaySamples = estimateDelay(left, right);\n    result.itd = (delaySamples / audio.sampleRate) * 1000; // ms\n  }\n\n  // ILD（両耳間レベル差）計算（オプション）\n  if (calculateILD) {\n    const rmsL = Math.sqrt(energyL / len);\n    const rmsR = Math.sqrt(energyR / len);\n\n    result.ild = rmsL > 1e-10 && rmsR > 1e-10 ? 20 * Math.log10(rmsR / rmsL) : 0;\n  }\n\n  // ゴニオメーター用データ（Lissajous表示）\n  result.goniometer = {\n    x: side, // L-R\n    y: mid // L+R\n  };\n\n  return result;\n}\n\n// 時系列ステレオ解析（将来の拡張用）\nexport function getTimeVaryingStereoAnalysis(\n  _audio: AudioData,\n  _options: StereoAnalysisOptions & { windowSize?: number } = {}\n): Promise<{\n  times: Float32Array;\n  correlation: Float32Array;\n  width: Float32Array;\n  balance: Float32Array;\n}> {\n  return Promise.reject(\n    new AudioInspectError(\n      'UNSUPPORTED_FORMAT',\n      '時系列ステレオ解析は将来のバージョンで実装予定です'\n    )\n  );\n}\n","import { AudioData } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\n\nexport interface VADOptions {\n  channel?: number;\n  frameSizeMs?: number;\n  hopSizeMs?: number;\n  method?: 'energy' | 'zcr' | 'combined' | 'adaptive';\n\n  // 閾値パラメータ\n  energyThreshold?: number; // 固定エネルギー閾値\n  zcrThresholdLow?: number; // ZCR下限（有声音）\n  zcrThresholdHigh?: number; // ZCR上限（無声音）\n\n  // 適応的閾値用パラメータ\n  adaptiveAlpha?: number; // 適応率 (0-1)\n  noiseFactor?: number; // ノイズレベルに対する倍率\n\n  // 時間制約\n  minSilenceDurationMs?: number;\n  minSpeechDurationMs?: number;\n\n  // 追加オプション\n  preEmphasis?: boolean; // プリエンファシスフィルタ\n  smoothing?: boolean; // 判定結果の平滑化\n}\n\nexport interface VADSegment {\n  start: number;\n  end: number;\n  type: 'speech' | 'silence';\n  confidence?: number; // 判定の信頼度 (0-1)\n}\n\nexport interface VADResult {\n  segments: VADSegment[];\n  speechRatio: number;\n  features?: {\n    energies: Float32Array;\n    zcrs: Float32Array;\n    decisions: Float32Array; // 0-1の連続値\n    times: Float32Array;\n  };\n}\n\n/**\n * プリエンファシスフィルタ\n */\nfunction applyPreEmphasis(data: Float32Array, alpha: number = 0.97): Float32Array {\n  const filtered = new Float32Array(data.length);\n  filtered[0] = data[0] || 0;\n\n  for (let i = 1; i < data.length; i++) {\n    const current = ensureValidSample(data[i]);\n    const previous = ensureValidSample(data[i - 1]);\n    filtered[i] = current - alpha * previous;\n  }\n\n  return filtered;\n}\n\n/**\n * フレームエネルギー計算\n */\nfunction calculateFrameEnergies(\n  channelData: Float32Array,\n  frameSizeSamples: number,\n  hopSizeSamples: number,\n  sampleRate: number,\n  useLogEnergy: boolean = false\n): { energies: Float32Array; times: Float32Array } {\n  const dataLength = channelData.length;\n\n  if (dataLength < frameSizeSamples) {\n    return { energies: new Float32Array(0), times: new Float32Array(0) };\n  }\n\n  const frameCount = Math.floor((dataLength - frameSizeSamples) / hopSizeSamples) + 1;\n  const energies = new Float32Array(frameCount);\n  const times = new Float32Array(frameCount);\n\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSizeSamples;\n    const end = Math.min(start + frameSizeSamples, dataLength);\n\n    let energy = 0;\n    let validSamples = 0;\n\n    for (let j = start; j < end; j++) {\n      const sample = ensureValidSample(channelData[j]);\n      energy += sample * sample;\n      validSamples++;\n    }\n\n    energy = validSamples > 0 ? energy / validSamples : 0; // 正規化\n\n    if (useLogEnergy) {\n      energies[i] = energy > 1e-10 ? 10 * Math.log10(energy) : -100;\n    } else {\n      energies[i] = energy;\n    }\n\n    times[i] = (start + frameSizeSamples / 2) / sampleRate;\n  }\n\n  return { energies, times };\n}\n\n/**\n * フレームZCR計算\n */\nfunction calculateFrameZCRs(\n  channelData: Float32Array,\n  frameSizeSamples: number,\n  hopSizeSamples: number,\n  normalize: boolean = true\n): Float32Array {\n  const dataLength = channelData.length;\n\n  if (dataLength < frameSizeSamples) {\n    return new Float32Array(0);\n  }\n\n  const frameCount = Math.floor((dataLength - frameSizeSamples) / hopSizeSamples) + 1;\n  const zcrs = new Float32Array(frameCount);\n\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSizeSamples;\n    const end = Math.min(start + frameSizeSamples, dataLength);\n\n    let crossings = 0;\n    let prevSign = Math.sign(ensureValidSample(channelData[start]));\n\n    for (let j = start + 1; j < end; j++) {\n      const sample = ensureValidSample(channelData[j]);\n      const currentSign = Math.sign(sample);\n      if (prevSign !== currentSign && prevSign !== 0 && currentSign !== 0) {\n        crossings++;\n      }\n      prevSign = currentSign;\n    }\n\n    zcrs[i] = normalize ? crossings / Math.max(1, end - start - 1) : crossings;\n  }\n\n  return zcrs;\n}\n\n/**\n * 適応的閾値の計算\n */\nfunction calculateAdaptiveThreshold(\n  values: Float32Array,\n  alpha: number,\n  noiseFactor: number,\n  initialFrames: number = 10\n): Float32Array {\n  const thresholds = new Float32Array(values.length);\n\n  // 初期ノイズレベルの推定（最初のフレームから）\n  let noiseLevel = 0;\n  const noiseFrames = Math.min(initialFrames, values.length);\n\n  for (let i = 0; i < noiseFrames; i++) {\n    const value = values[i];\n    if (value !== undefined) {\n      noiseLevel += value;\n    }\n  }\n  noiseLevel = noiseFrames > 0 ? noiseLevel / noiseFrames : 0;\n\n  // 適応的閾値の計算\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (value === undefined) {\n      thresholds[i] =\n        i > 0 ? (thresholds[i - 1] ?? noiseLevel * noiseFactor) : noiseLevel * noiseFactor;\n      continue;\n    }\n\n    if (i === 0) {\n      thresholds[i] = noiseLevel * noiseFactor;\n    } else {\n      const prevThreshold = thresholds[i - 1];\n      // 指数移動平均によるノイズレベルの更新\n      if (prevThreshold !== undefined && value < prevThreshold) {\n        noiseLevel = alpha * noiseLevel + (1 - alpha) * value;\n      }\n      thresholds[i] = noiseLevel * noiseFactor;\n    }\n  }\n\n  return thresholds;\n}\n\n/**\n * 判定結果の平滑化（メディアンフィルタ）\n */\nfunction smoothDecisions(decisions: Float32Array, windowSize: number = 5): Float32Array {\n  const smoothed = new Float32Array(decisions.length);\n  const halfWindow = Math.floor(windowSize / 2);\n\n  for (let i = 0; i < decisions.length; i++) {\n    const start = Math.max(0, i - halfWindow);\n    const end = Math.min(decisions.length, i + halfWindow + 1);\n\n    // 窓内の値を収集してソート\n    const windowValues: number[] = [];\n    for (let j = start; j < end; j++) {\n      const value = decisions[j];\n      if (value !== undefined) {\n        windowValues.push(value);\n      }\n    }\n    windowValues.sort((a, b) => a - b);\n\n    // メディアン値を取得\n    if (windowValues.length > 0) {\n      const medianIdx = Math.floor(windowValues.length / 2);\n      const medianValue = windowValues[medianIdx];\n      smoothed[i] = medianValue ?? 0;\n    } else {\n      smoothed[i] = 0;\n    }\n  }\n\n  return smoothed;\n}\n\n/**\n * セグメント化（連続値から）\n */\nfunction createSegmentsFromContinuous(\n  decisions: Float32Array,\n  times: Float32Array,\n  threshold: number = 0.5,\n  minSpeechSec: number = 0.1,\n  minSilenceSec: number = 0.3\n): VADSegment[] {\n  const segments: VADSegment[] = [];\n  let currentSegment: VADSegment | null = null;\n\n  for (let i = 0; i < decisions.length; i++) {\n    const decision = decisions[i];\n    const time = times[i];\n    if (decision === undefined || time === undefined) continue;\n\n    const isSpeech = decision >= threshold;\n\n    if (!currentSegment) {\n      currentSegment = {\n        start: time,\n        end: time,\n        type: isSpeech ? 'speech' : 'silence',\n        confidence: Math.abs(decision - 0.5) * 2\n      };\n    } else if (\n      (isSpeech && currentSegment.type === 'speech') ||\n      (!isSpeech && currentSegment.type === 'silence')\n    ) {\n      // 同じタイプのセグメントを延長\n      currentSegment.end = time;\n      const conf = Math.abs(decision - 0.5) * 2;\n      currentSegment.confidence = Math.max(currentSegment.confidence || 0, conf);\n    } else {\n      // タイプが変わった場合\n      segments.push(currentSegment);\n      currentSegment = {\n        start: time,\n        end: time,\n        type: isSpeech ? 'speech' : 'silence',\n        confidence: Math.abs(decision - 0.5) * 2\n      };\n    }\n  }\n\n  if (currentSegment) {\n    segments.push(currentSegment);\n  }\n\n  // 短いセグメントのフィルタリング\n  return filterShortSegments(segments, minSpeechSec, minSilenceSec);\n}\n\n/**\n * 短いセグメントのフィルタリング\n */\nfunction filterShortSegments(\n  segments: VADSegment[],\n  minSpeechSec: number,\n  minSilenceSec: number\n): VADSegment[] {\n  if (segments.length === 0) return [];\n\n  const filtered: VADSegment[] = [];\n  let i = 0;\n\n  while (i < segments.length) {\n    const current = segments[i];\n    if (!current) {\n      i++;\n      continue;\n    }\n\n    const duration = current.end - current.start;\n\n    if (\n      (current.type === 'speech' && duration >= minSpeechSec) ||\n      (current.type === 'silence' && duration >= minSilenceSec)\n    ) {\n      // セグメントを保持\n      filtered.push(current);\n      i++;\n    } else {\n      // 短いセグメントの処理\n      if (filtered.length > 0 && i + 1 < segments.length) {\n        const prev = filtered[filtered.length - 1];\n        const next = segments[i + 1];\n\n        if (prev && next && prev.type === next.type) {\n          // 前後が同じタイプなら統合\n          prev.end = next.end;\n          i += 2; // 現在と次のセグメントをスキップ\n          continue;\n        }\n      }\n\n      // 統合できない場合はタイプを変更\n      if (filtered.length > 0) {\n        const lastFiltered = filtered[filtered.length - 1];\n        if (lastFiltered) {\n          lastFiltered.end = current.end;\n        }\n      }\n      i++;\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * VAD（音声区間検出）を実行\n */\nexport function getVAD(audio: AudioData, options: VADOptions = {}): VADResult {\n  const {\n    channel = 0,\n    frameSizeMs = 30, // 30msフレーム\n    hopSizeMs = 10, // 10msホップ\n    method = 'combined',\n    energyThreshold = 0.02,\n    zcrThresholdLow = 0.05,\n    zcrThresholdHigh = 0.15,\n    adaptiveAlpha = 0.99,\n    noiseFactor = 3.0,\n    minSilenceDurationMs = 300,\n    minSpeechDurationMs = 100,\n    preEmphasis = true,\n    smoothing = true\n  } = options;\n\n  let channelData = getChannelData(audio, channel);\n\n  // プリエンファシス（オプション）\n  if (preEmphasis) {\n    channelData = applyPreEmphasis(channelData);\n  }\n\n  const sr = audio.sampleRate;\n  const frameSizeSamples = Math.floor((frameSizeMs / 1000) * sr);\n  const hopSizeSamples = Math.floor((hopSizeMs / 1000) * sr);\n\n  if (frameSizeSamples === 0 || hopSizeSamples === 0) {\n    return { segments: [], speechRatio: 0 };\n  }\n\n  // 特徴量の計算\n  const { energies, times } = calculateFrameEnergies(\n    channelData,\n    frameSizeSamples,\n    hopSizeSamples,\n    sr,\n    false\n  );\n\n  const zcrs = calculateFrameZCRs(channelData, frameSizeSamples, hopSizeSamples, true);\n\n  if (energies.length === 0) {\n    return { segments: [], speechRatio: 0 };\n  }\n\n  // VAD判定\n  const decisions = new Float32Array(energies.length);\n\n  switch (method) {\n    case 'energy': {\n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        decisions[i] = energy !== undefined && energy > energyThreshold ? 1 : 0;\n      }\n      break;\n    }\n\n    case 'zcr': {\n      for (let i = 0; i < zcrs.length; i++) {\n        const zcr = zcrs[i];\n        decisions[i] = zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 1 : 0;\n      }\n      break;\n    }\n\n    case 'combined': {\n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        const zcr = zcrs[i];\n\n        const energyScore = energy !== undefined && energy > energyThreshold ? 1 : 0;\n        const zcrScore =\n          zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 1 : 0;\n        decisions[i] = (energyScore + zcrScore) / 2;\n      }\n      break;\n    }\n\n    case 'adaptive': {\n      // 適応的閾値の計算\n      const adaptiveThreshold = calculateAdaptiveThreshold(energies, adaptiveAlpha, noiseFactor);\n\n      for (let i = 0; i < energies.length; i++) {\n        const energy = energies[i];\n        const zcr = zcrs[i];\n        const threshold = adaptiveThreshold[i];\n\n        const energyScore =\n          energy !== undefined && threshold !== undefined && energy > threshold ? 1 : 0;\n        const zcrScore =\n          zcr !== undefined && zcr > zcrThresholdLow && zcr < zcrThresholdHigh ? 0.5 : 0;\n        decisions[i] = Math.min(1, energyScore + zcrScore);\n      }\n      break;\n    }\n  }\n\n  // 平滑化（オプション）\n  const finalDecisions = smoothing ? smoothDecisions(decisions, 5) : decisions;\n\n  // セグメント化\n  const minSpeechSec = minSpeechDurationMs / 1000;\n  const minSilenceSec = minSilenceDurationMs / 1000;\n\n  const segments = createSegmentsFromContinuous(\n    finalDecisions,\n    times,\n    0.5,\n    minSpeechSec,\n    minSilenceSec\n  );\n\n  // 音声区間の割合計算\n  let totalSpeechDuration = 0;\n  for (const seg of segments) {\n    if (seg.type === 'speech') {\n      totalSpeechDuration += seg.end - seg.start;\n    }\n  }\n\n  const speechRatio = audio.duration > 0 ? Math.min(1, totalSpeechDuration / audio.duration) : 0;\n\n  return {\n    segments,\n    speechRatio,\n    features: {\n      energies,\n      zcrs,\n      decisions: finalDecisions,\n      times\n    }\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { ensureValidSample } from '../core/utils.js';\n\n// ITU-R BS.1770-4準拠の定数\nconst ABSOLUTE_GATE_LUFS = -70.0;\nconst RELATIVE_GATE_LU = 10.0;\nconst BLOCK_SIZE_MS = 400;\nconst BLOCK_OVERLAP = 0.75; // 75%オーバーラップ\nconst SHORT_TERM_WINDOW_MS = 3000;\nconst MOMENTARY_WINDOW_MS = 400;\n\n// K-weighting filter coefficients (ITU-R BS.1770-4)\nconst K_WEIGHTING_STAGE1 = {\n  // High-pass filter (Butterworth)\n  b: [1.53512485958697, -2.69169618940638, 1.19839281085285],\n  a: [1.0, -1.69065929318241, 0.73248077421585]\n};\n\nconst K_WEIGHTING_STAGE2 = {\n  // High-frequency shelf\n  b: [1.53660026327012, -2.68908427791073, 1.16158667615261],\n  a: [1.0, -1.68859431835989, 0.72909998803284]\n};\n\n// Biquadフィルタの状態\ninterface BiquadState {\n  x1: number;\n  x2: number;\n  y1: number;\n  y2: number;\n}\n\n// Biquadフィルタの適用\nfunction applyBiquad(\n  input: Float32Array,\n  b: number[],\n  a: number[],\n  state: BiquadState = { x1: 0, x2: 0, y1: 0, y2: 0 }\n): Float32Array {\n  const output = new Float32Array(input.length);\n  let { x1, x2, y1, y2 } = state;\n\n  for (let i = 0; i < input.length; i++) {\n    const x0 = ensureValidSample(input[i]);\n    const b0 = b[0] ?? 0;\n    const b1 = b[1] ?? 0;\n    const b2 = b[2] ?? 0;\n    const a1 = a[1] ?? 0;\n    const a2 = a[2] ?? 0;\n\n    const y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;\n\n    output[i] = y0;\n\n    x2 = x1;\n    x1 = x0;\n    y2 = y1;\n    y1 = y0;\n  }\n\n  // 状態を更新\n  state.x1 = x1;\n  state.x2 = x2;\n  state.y1 = y1;\n  state.y2 = y2;\n\n  return output;\n}\n\n// K-weightingフィルタの適用\nfunction applyKWeighting(channelData: Float32Array): Float32Array {\n  // ステージ1: ハイパスフィルタ\n  let filtered = applyBiquad(channelData, K_WEIGHTING_STAGE1.b, K_WEIGHTING_STAGE1.a);\n\n  // ステージ2: 高周波シェルフ\n  filtered = applyBiquad(filtered, K_WEIGHTING_STAGE2.b, K_WEIGHTING_STAGE2.a);\n\n  return filtered;\n}\n\n// ブロックのラウドネス計算\nfunction calculateBlockLoudness(channels: Float32Array[]): number {\n  let sumOfSquares = 0;\n  const numChannels = channels.length;\n\n  if (numChannels === 0) return -Infinity;\n\n  for (let ch = 0; ch < numChannels; ch++) {\n    const channelData = channels[ch];\n    if (!channelData || channelData.length === 0) continue;\n\n    let channelSum = 0;\n    let validSamples = 0;\n\n    for (let i = 0; i < channelData.length; i++) {\n      const sample = ensureValidSample(channelData[i]);\n      channelSum += sample * sample;\n      validSamples++;\n    }\n\n    if (validSamples === 0) continue;\n\n    // チャンネル重み付け（ステレオの場合）\n    const channelWeight = 1.0; // L, R, Cは1.0、Ls, Rsは1.41（サラウンドの場合）\n    sumOfSquares += channelWeight * (channelSum / validSamples);\n  }\n\n  // LUFSに変換\n  return -0.691 + 10 * Math.log10(Math.max(1e-15, sumOfSquares));\n}\n\nexport interface LUFSOptions {\n  channelMode?: 'mono' | 'stereo';\n  gated?: boolean;\n  calculateShortTerm?: boolean;\n  calculateMomentary?: boolean;\n  calculateLoudnessRange?: boolean;\n  calculateTruePeak?: boolean;\n}\n\nexport interface LUFSResult {\n  integrated: number; // Integrated loudness (LUFS)\n  shortTerm?: Float32Array; // Short-term loudness values\n  momentary?: Float32Array; // Momentary loudness values\n  loudnessRange?: number; // Loudness range (LU)\n  truePeak?: number[]; // True peak per channel (dBTP)\n  statistics?: {\n    percentile10: number; // 10th percentile\n    percentile95: number; // 95th percentile\n  };\n}\n\nexport function getLUFS(audio: AudioData, options: LUFSOptions = {}): LUFSResult {\n  const {\n    channelMode = audio.numberOfChannels >= 2 ? 'stereo' : 'mono',\n    gated = true,\n    calculateShortTerm = false,\n    calculateMomentary = false,\n    calculateLoudnessRange = false,\n    calculateTruePeak = false\n  } = options;\n\n  if (audio.numberOfChannels === 0) {\n    throw new AudioInspectError('INVALID_INPUT', '処理可能なチャンネルがありません');\n  }\n\n  // チャンネルデータの準備\n  const channelsToProcess: Float32Array[] = [];\n\n  if (channelMode === 'mono') {\n    const channel0 = audio.channelData[0];\n    if (channel0) {\n      channelsToProcess.push(channel0);\n    }\n  } else {\n    // ステレオ処理\n    const channel0 = audio.channelData[0];\n    const channel1 = audio.channelData[1];\n    if (channel0) channelsToProcess.push(channel0);\n    if (channel1) channelsToProcess.push(channel1);\n  }\n\n  if (channelsToProcess.length === 0) {\n    throw new AudioInspectError('INVALID_INPUT', '処理可能なチャンネルがありません');\n  }\n\n  // K-weightingの適用\n  const kWeightedChannels = channelsToProcess.map((ch) => applyKWeighting(ch));\n\n  // ブロック処理のパラメータ\n  const sampleRate = audio.sampleRate;\n  const blockSizeSamples = Math.floor((BLOCK_SIZE_MS / 1000) * sampleRate);\n  const hopSizeSamples = Math.floor(blockSizeSamples * (1 - BLOCK_OVERLAP));\n  const dataLength = kWeightedChannels[0]?.length ?? 0;\n\n  if (dataLength === 0) {\n    return { integrated: -Infinity };\n  }\n\n  // Integrated Loudness の計算\n  const blockLoudnessValues: number[] = [];\n\n  for (let pos = 0; pos + blockSizeSamples <= dataLength; pos += hopSizeSamples) {\n    const blockChannels = kWeightedChannels.map((ch) => ch.subarray(pos, pos + blockSizeSamples));\n\n    const loudness = calculateBlockLoudness(blockChannels);\n    if (isFinite(loudness)) {\n      blockLoudnessValues.push(loudness);\n    }\n  }\n\n  let integratedLoudness = -Infinity;\n\n  if (blockLoudnessValues.length > 0) {\n    let finalLoudnessValues = [...blockLoudnessValues];\n\n    if (gated) {\n      // 絶対ゲート（-70 LUFS）\n      finalLoudnessValues = finalLoudnessValues.filter((l) => l >= ABSOLUTE_GATE_LUFS);\n\n      if (finalLoudnessValues.length > 0) {\n        // 相対ゲートのための平均計算\n        const sumPower = finalLoudnessValues.reduce((sum, lufs) => {\n          return sum + Math.pow(10, (lufs + 0.691) / 10);\n        }, 0);\n\n        const meanLoudness = -0.691 + 10 * Math.log10(sumPower / finalLoudnessValues.length);\n        const relativeThreshold = meanLoudness - RELATIVE_GATE_LU;\n\n        // 相対ゲート適用\n        finalLoudnessValues = finalLoudnessValues.filter((l) => l >= relativeThreshold);\n      }\n    }\n\n    if (finalLoudnessValues.length > 0) {\n      // 最終的なIntegrated Loudness\n      const sumPower = finalLoudnessValues.reduce((sum, lufs) => {\n        return sum + Math.pow(10, (lufs + 0.691) / 10);\n      }, 0);\n\n      integratedLoudness = -0.691 + 10 * Math.log10(sumPower / finalLoudnessValues.length);\n    }\n  }\n\n  const result: LUFSResult = {\n    integrated: integratedLoudness\n  };\n\n  // Short-term Loudness（オプション）\n  if (calculateShortTerm) {\n    const shortTermSamples = Math.floor((SHORT_TERM_WINDOW_MS / 1000) * sampleRate);\n    const shortTermHop = hopSizeSamples;\n    const shortTermValues: number[] = [];\n\n    for (let pos = 0; pos + shortTermSamples <= dataLength; pos += shortTermHop) {\n      const windowChannels = kWeightedChannels.map((ch) =>\n        ch.subarray(pos, pos + shortTermSamples)\n      );\n\n      const loudness = calculateBlockLoudness(windowChannels);\n      if (isFinite(loudness)) {\n        shortTermValues.push(loudness);\n      }\n    }\n\n    result.shortTerm = new Float32Array(shortTermValues);\n  }\n\n  // Momentary Loudness（オプション）\n  if (calculateMomentary) {\n    const momentarySamples = Math.floor((MOMENTARY_WINDOW_MS / 1000) * sampleRate);\n    const momentaryHop = hopSizeSamples;\n    const momentaryValues: number[] = [];\n\n    for (let pos = 0; pos + momentarySamples <= dataLength; pos += momentaryHop) {\n      const windowChannels = kWeightedChannels.map((ch) =>\n        ch.subarray(pos, pos + momentarySamples)\n      );\n\n      const loudness = calculateBlockLoudness(windowChannels);\n      if (isFinite(loudness)) {\n        momentaryValues.push(loudness);\n      }\n    }\n\n    result.momentary = new Float32Array(momentaryValues);\n  }\n\n  // Loudness Range（オプション）\n  if (calculateLoudnessRange && result.shortTerm) {\n    const validValues = Array.from(result.shortTerm)\n      .filter((v) => v > ABSOLUTE_GATE_LUFS && isFinite(v))\n      .sort((a, b) => a - b);\n\n    if (validValues.length > 0) {\n      const percentile10Index = Math.floor(validValues.length * 0.1);\n      const percentile95Index = Math.floor(validValues.length * 0.95);\n\n      const percentile10 = validValues[percentile10Index] ?? -Infinity;\n      const percentile95 = validValues[percentile95Index] ?? -Infinity;\n\n      result.loudnessRange = percentile95 - percentile10;\n      result.statistics = { percentile10, percentile95 };\n    }\n  }\n\n  // True Peak（オプション - 簡易実装）\n  if (calculateTruePeak) {\n    result.truePeak = channelsToProcess.map((ch) => {\n      let peak = 0;\n      for (const sample of ch) {\n        const sampleValue = ensureValidSample(sample);\n        peak = Math.max(peak, Math.abs(sampleValue));\n      }\n      return peak > 0 ? 20 * Math.log10(peak) : -Infinity;\n    });\n  }\n\n  return result;\n}\n"],"mappings":"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","names":["channelData","SILENCE_DB","getChannelData","channelData"]}