{"version":3,"sources":["../../src/types.ts","../../src/core/utils.ts","../../src/features/energy.ts"],"sourcesContent":["/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED';\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\n\nexport interface EnergyOptions {\n  frameSize?: number;\n  hopSize?: number;\n  channel?: number;\n  normalized?: boolean;\n  windowFunction?: 'rectangular' | 'hann' | 'hamming'; // エネルギー計算用の窓関数\n}\n\nexport interface EnergyResult {\n  times: Float32Array;\n  energies: Float32Array;\n  totalEnergy: number;\n  statistics: {\n    mean: number;\n    std: number;\n    max: number;\n    min: number;\n  };\n}\n\n// 窓関数の適用（エネルギー計算用）\nfunction applyEnergyWindow(\n  data: Float32Array,\n  windowType: string,\n  startIdx: number,\n  length: number\n): Float32Array {\n  const windowed = new Float32Array(length);\n\n  for (let i = 0; i < length && startIdx + i < data.length; i++) {\n    let windowValue = 1.0;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (length - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (length - 1));\n        break;\n      case 'rectangular':\n      default:\n        windowValue = 1.0;\n    }\n\n    const sample = ensureValidSample(data[startIdx + i]);\n    windowed[i] = sample * windowValue;\n  }\n\n  return windowed;\n}\n\nexport function getEnergy(audio: AudioData, options: EnergyOptions = {}): EnergyResult {\n  const {\n    frameSize = Math.floor(audio.sampleRate * 0.025), // 25ms\n    hopSize = Math.floor(audio.sampleRate * 0.01), // 10ms\n    channel = 0,\n    normalized = false,\n    windowFunction = 'rectangular'\n  } = options;\n\n  // パラメータの検証\n  if (frameSize <= 0 || !Number.isInteger(frameSize)) {\n    throw new AudioInspectError('INVALID_INPUT', 'frameSizeは正の整数である必要があります');\n  }\n\n  if (hopSize <= 0 || !Number.isInteger(hopSize)) {\n    throw new AudioInspectError('INVALID_INPUT', 'hopSizeは正の整数である必要があります');\n  }\n\n  if (hopSize > frameSize) {\n    console.warn(\n      '[audio-inspect] hopSizeがframeSizeより大きいため、フレーム間にギャップが生じます'\n    );\n  }\n\n  const channelData = getChannelData(audio, channel);\n  const dataLength = channelData.length;\n\n  if (dataLength === 0) {\n    return {\n      times: new Float32Array(0),\n      energies: new Float32Array(0),\n      totalEnergy: 0,\n      statistics: { mean: 0, std: 0, max: 0, min: 0 }\n    };\n  }\n\n  // フレーム数の計算\n  const frameCount = Math.max(0, Math.floor((dataLength - frameSize) / hopSize) + 1);\n\n  if (frameCount === 0) {\n    // データが1フレーム分に満たない場合\n    const energy = calculateFrameEnergy(channelData, 0, dataLength, windowFunction);\n    return {\n      times: new Float32Array([dataLength / 2 / audio.sampleRate]),\n      energies: new Float32Array([energy]),\n      totalEnergy: energy,\n      statistics: { mean: energy, std: 0, max: energy, min: energy }\n    };\n  }\n\n  const times = new Float32Array(frameCount);\n  const energies = new Float32Array(frameCount);\n  let totalEnergy = 0;\n  let maxEnergy = -Infinity;\n  let minEnergy = Infinity;\n\n  // 各フレームのエネルギー計算\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSize;\n    const windowedFrame = applyEnergyWindow(channelData, windowFunction, start, frameSize);\n\n    let frameEnergy = 0;\n    for (let j = 0; j < windowedFrame.length; j++) {\n      const sample = windowedFrame[j];\n      if (sample !== undefined) {\n        frameEnergy += sample * sample;\n      }\n    }\n\n    times[i] = (start + frameSize / 2) / audio.sampleRate;\n    energies[i] = frameEnergy;\n    totalEnergy += frameEnergy;\n\n    maxEnergy = Math.max(maxEnergy, frameEnergy);\n    minEnergy = Math.min(minEnergy, frameEnergy);\n  }\n\n  // 統計情報の計算\n  const meanEnergy = totalEnergy / frameCount;\n  let varianceSum = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const energy = energies[i];\n    if (energy !== undefined) {\n      const diff = energy - meanEnergy;\n      varianceSum += diff * diff;\n    }\n  }\n\n  const stdEnergy = Math.sqrt(varianceSum / frameCount);\n\n  // 正規化（オプション）\n  if (normalized && totalEnergy > 1e-10) {\n    for (let i = 0; i < energies.length; i++) {\n      const currentEnergy = energies[i];\n      if (currentEnergy !== undefined) {\n        energies[i] = currentEnergy / totalEnergy;\n      }\n    }\n\n    return {\n      times,\n      energies,\n      totalEnergy: 1.0,\n      statistics: {\n        mean: meanEnergy / totalEnergy,\n        std: stdEnergy / totalEnergy,\n        max: maxEnergy / totalEnergy,\n        min: minEnergy / totalEnergy\n      }\n    };\n  }\n\n  return {\n    times,\n    energies,\n    totalEnergy,\n    statistics: {\n      mean: meanEnergy,\n      std: stdEnergy,\n      max: maxEnergy,\n      min: minEnergy\n    }\n  };\n}\n\n// ヘルパー関数\nfunction calculateFrameEnergy(\n  data: Float32Array,\n  start: number,\n  length: number,\n  windowFunction: string\n): number {\n  const windowed = applyEnergyWindow(data, windowFunction, start, length);\n  let energy = 0;\n  for (const sample of windowed) {\n    energy += sample * sample;\n  }\n  return energy;\n}\n"],"mappings":"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","names":["channelData"]}