{"version":3,"sources":["../../src/features/spectral.ts","../../src/types.ts","../../src/core/utils.ts","../../src/core/fft-provider.ts","../../src/features/frequency.ts"],"sourcesContent":["import { AudioData, AudioInspectError } from '../types';\nimport { ensureValidSample } from '../core/utils';\nimport { getFFT } from './frequency';\n\n/**\n * スペクトル特徴量のオプション\n */\nexport interface SpectralFeaturesOptions {\n  /** FFTサイズ */\n  fftSize?: number;\n  /** 窓関数 */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** 解析するチャンネル */\n  channel?: number;\n  /** 最小周波数 */\n  minFrequency?: number;\n  /** 最大周波数 */\n  maxFrequency?: number;\n  /** スペクトルロールオフの閾値（0-1） */\n  rolloffThreshold?: number;\n}\n\n/**\n * スペクトル特徴量の結果\n */\nexport interface SpectralFeaturesResult {\n  /** スペクトル重心（Hz） */\n  spectralCentroid: number;\n  /** スペクトル帯域幅（Hz） */\n  spectralBandwidth: number;\n  /** スペクトルロールオフ（Hz） */\n  spectralRolloff: number;\n  /** スペクトルフラットネス（0-1） */\n  spectralFlatness: number;\n  /** スペクトルフラックス */\n  spectralFlux?: number;\n  /** ゼロ交差率 */\n  zeroCrossingRate: number;\n  /** 使用された周波数範囲 */\n  frequencyRange: { min: number; max: number };\n}\n\n/**\n * 時系列スペクトル特徴量のオプション\n */\nexport interface TimeVaryingSpectralOptions extends SpectralFeaturesOptions {\n  /** フレームサイズ */\n  frameSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** フレーム数（指定しない場合は全体を解析） */\n  numFrames?: number;\n}\n\n/**\n * 時系列スペクトル特徴量の結果\n */\nexport interface TimeVaryingSpectralResult {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** スペクトル重心の時系列 */\n  spectralCentroid: Float32Array;\n  /** スペクトル帯域幅の時系列 */\n  spectralBandwidth: Float32Array;\n  /** スペクトルロールオフの時系列 */\n  spectralRolloff: Float32Array;\n  /** スペクトルフラットネスの時系列 */\n  spectralFlatness: Float32Array;\n  /** スペクトルフラックスの時系列 */\n  spectralFlux: Float32Array;\n  /** ゼロ交差率の時系列 */\n  zeroCrossingRate: Float32Array;\n  /** フレーム情報 */\n  frameInfo: {\n    frameSize: number;\n    hopSize: number;\n    numFrames: number;\n  };\n}\n\n/**\n * スペクトル重心を計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトル重心（Hz）\n */\nfunction calculateSpectralCentroid(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  minFreq: number,\n  maxFreq: number\n): number {\n  let weightedSum = 0;\n  let magnitudeSum = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      weightedSum += freq * mag;\n      magnitudeSum += mag;\n    }\n  }\n\n  return magnitudeSum > 1e-10 ? weightedSum / magnitudeSum : 0;\n}\n\n/**\n * スペクトル帯域幅を計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param centroid スペクトル重心\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトル帯域幅（Hz）\n */\nfunction calculateSpectralBandwidth(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  centroid: number,\n  minFreq: number,\n  maxFreq: number\n): number {\n  let weightedVarianceSum = 0;\n  let magnitudeSum = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      const deviation = freq - centroid;\n      weightedVarianceSum += deviation * deviation * mag;\n      magnitudeSum += mag;\n    }\n  }\n\n  return magnitudeSum > 1e-10 ? Math.sqrt(weightedVarianceSum / magnitudeSum) : 0;\n}\n\n/**\n * スペクトルロールオフを計算\n * @param magnitude スペクトル振幅\n * @param frequencies 周波数配列\n * @param threshold 閾値（0-1）\n * @param minFreq 最小周波数\n * @param maxFreq 最大周波数\n * @returns スペクトルロールオフ（Hz）\n */\nfunction calculateSpectralRolloff(\n  magnitude: Float32Array,\n  frequencies: Float32Array,\n  threshold: number,\n  minFreq: number,\n  maxFreq: number\n): number {\n  // 指定範囲内の総エネルギーを計算\n  let totalEnergy = 0;\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      totalEnergy += mag * mag;\n    }\n  }\n\n  const targetEnergy = totalEnergy * threshold;\n  let cumulativeEnergy = 0;\n\n  for (let i = 0; i < magnitude.length && i < frequencies.length; i++) {\n    const freq = frequencies[i];\n    const mag = magnitude[i];\n    if (freq !== undefined && mag !== undefined && freq >= minFreq && freq <= maxFreq) {\n      cumulativeEnergy += mag * mag;\n      if (cumulativeEnergy >= targetEnergy) {\n        return freq;\n      }\n    }\n  }\n\n  return maxFreq;\n}\n\n/**\n * スペクトルフラットネスを計算\n * @param magnitude スペクトル振幅\n * @param minIndex 最小インデックス\n * @param maxIndex 最大インデックス\n * @returns スペクトルフラットネス（0-1）\n */\nfunction calculateSpectralFlatness(\n  magnitude: Float32Array,\n  minIndex: number,\n  maxIndex: number\n): number {\n  let geometricMean = 0;\n  let arithmeticMean = 0;\n  let count = 0;\n\n  for (let i = minIndex; i <= maxIndex && i < magnitude.length; i++) {\n    const mag = magnitude[i];\n    if (mag !== undefined) {\n      const safeMag = Math.max(mag, 1e-10); // ゼロ除算を防ぐ\n      geometricMean += Math.log(safeMag);\n      arithmeticMean += safeMag;\n      count++;\n    }\n  }\n\n  if (count === 0) return 0;\n\n  geometricMean = Math.exp(geometricMean / count);\n  arithmeticMean = arithmeticMean / count;\n\n  return arithmeticMean > 1e-10 ? geometricMean / arithmeticMean : 0;\n}\n\n/**\n * ゼロ交差率を計算\n * @param samples 音声サンプル\n * @returns ゼロ交差率\n */\nfunction calculateZeroCrossingRate(samples: Float32Array): number {\n  if (samples.length < 2) return 0;\n\n  let crossings = 0;\n  for (let i = 1; i < samples.length; i++) {\n    const prev = ensureValidSample(samples[i - 1]);\n    const curr = ensureValidSample(samples[i]);\n    \n    if ((prev >= 0 && curr < 0) || (prev < 0 && curr >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (samples.length - 1);\n}\n\n/**\n * スペクトルフラックスを計算\n * @param currentMagnitude 現在のフレームのスペクトル振幅\n * @param previousMagnitude 前のフレームのスペクトル振幅\n * @returns スペクトルフラックス\n */\nfunction calculateSpectralFlux(\n  currentMagnitude: Float32Array,\n  previousMagnitude?: Float32Array\n): number {\n  if (!previousMagnitude) return 0;\n\n  let flux = 0;\n  const length = Math.min(currentMagnitude.length, previousMagnitude.length);\n\n  for (let i = 0; i < length; i++) {\n    const current = currentMagnitude[i];\n    const previous = previousMagnitude[i];\n    if (current !== undefined && previous !== undefined) {\n      const diff = current - previous;\n      flux += diff * diff;\n    }\n  }\n\n  return Math.sqrt(flux / length);\n}\n\n/**\n * 単一フレームのスペクトル特徴量を計算\n * @param audio 音声データ\n * @param options オプション\n * @returns スペクトル特徴量\n */\nexport async function getSpectralFeatures(\n  audio: AudioData,\n  options: SpectralFeaturesOptions = {}\n): Promise<SpectralFeaturesResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    rolloffThreshold = 0.85\n  } = options;\n\n  if (channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}`\n    );\n  }\n\n  // FFT解析\n  const fftResult = await getFFT(audio, {\n    fftSize,\n    windowFunction,\n    channel\n  });\n\n  // 周波数範囲のインデックスを計算\n  const minIndex = Math.max(0, Math.floor(minFrequency * fftSize / audio.sampleRate));\n  const maxIndex = Math.min(\n    fftResult.frequencies.length - 1,\n    Math.floor(maxFrequency * fftSize / audio.sampleRate)\n  );\n\n  // スペクトル重心\n  const spectralCentroid = calculateSpectralCentroid(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトル帯域幅\n  const spectralBandwidth = calculateSpectralBandwidth(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    spectralCentroid,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトルロールオフ\n  const spectralRolloff = calculateSpectralRolloff(\n    fftResult.magnitude,\n    fftResult.frequencies,\n    rolloffThreshold,\n    minFrequency,\n    maxFrequency\n  );\n\n  // スペクトルフラットネス\n  const spectralFlatness = calculateSpectralFlatness(\n    fftResult.magnitude,\n    minIndex,\n    maxIndex\n  );\n\n  // ゼロ交差率\n  const samples = audio.channelData[channel];\n  if (!samples) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n  const zeroCrossingRate = calculateZeroCrossingRate(samples);\n\n  return {\n    spectralCentroid,\n    spectralBandwidth,\n    spectralRolloff,\n    spectralFlatness,\n    zeroCrossingRate,\n    frequencyRange: {\n      min: minFrequency,\n      max: maxFrequency\n    }\n  };\n}\n\n/**\n * 時系列スペクトル特徴量を計算\n * @param audio 音声データ\n * @param options オプション\n * @returns 時系列スペクトル特徴量\n */\nexport async function getTimeVaryingSpectralFeatures(\n  audio: AudioData,\n  options: TimeVaryingSpectralOptions = {}\n): Promise<TimeVaryingSpectralResult> {\n  const {\n    frameSize = 2048,\n    hopSize = frameSize / 2,\n    fftSize = frameSize,\n    windowFunction = 'hann',\n    channel = 0,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    rolloffThreshold = 0.85,\n    numFrames\n  } = options;\n\n  if (channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}`\n    );\n  }\n\n  const samples = audio.channelData[channel];\n  if (!samples) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n  \n  const totalFrames = numFrames || Math.floor((samples.length - frameSize) / hopSize) + 1;\n  \n  if (totalFrames <= 0) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      'フレーム数が不正です'\n    );\n  }\n\n  // 結果配列の初期化\n  const times = new Float32Array(totalFrames);\n  const spectralCentroid = new Float32Array(totalFrames);\n  const spectralBandwidth = new Float32Array(totalFrames);\n  const spectralRolloff = new Float32Array(totalFrames);\n  const spectralFlatness = new Float32Array(totalFrames);\n  const spectralFlux = new Float32Array(totalFrames);\n  const zeroCrossingRate = new Float32Array(totalFrames);\n\n  let previousMagnitude: Float32Array | undefined;\n\n  // フレームごとの解析\n  for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {\n    const startSample = frameIndex * hopSize;\n    const endSample = Math.min(startSample + frameSize, samples.length);\n    \n    // 時間位置\n    times[frameIndex] = startSample / audio.sampleRate;\n\n    // フレームデータの抽出\n    const frameData = samples.subarray(startSample, endSample);\n    \n    // 短いフレームの場合はゼロパディング\n    const paddedFrame = new Float32Array(frameSize);\n    paddedFrame.set(frameData);\n\n    // フレーム用の音声データを作成\n    const frameAudio: AudioData = {\n      channelData: [paddedFrame],\n      sampleRate: audio.sampleRate,\n      numberOfChannels: 1,\n      length: frameSize,\n      duration: frameSize / audio.sampleRate\n    };\n\n    // スペクトル特徴量を計算\n    const features = await getSpectralFeatures(frameAudio, {\n      fftSize,\n      windowFunction,\n      channel: 0,\n      minFrequency,\n      maxFrequency,\n      rolloffThreshold\n    });\n\n    spectralCentroid[frameIndex] = features.spectralCentroid;\n    spectralBandwidth[frameIndex] = features.spectralBandwidth;\n    spectralRolloff[frameIndex] = features.spectralRolloff;\n    spectralFlatness[frameIndex] = features.spectralFlatness;\n    zeroCrossingRate[frameIndex] = features.zeroCrossingRate;\n\n    // スペクトルフラックスの計算（前フレームとの比較）\n    const fftResult = await getFFT(frameAudio, { fftSize, windowFunction, channel: 0 });\n    spectralFlux[frameIndex] = calculateSpectralFlux(fftResult.magnitude, previousMagnitude);\n    previousMagnitude = new Float32Array(fftResult.magnitude);\n  }\n\n  return {\n    times,\n    spectralCentroid,\n    spectralBandwidth,\n    spectralRolloff,\n    spectralFlatness,\n    spectralFlux,\n    zeroCrossingRate,\n    frameInfo: {\n      frameSize,\n      hopSize,\n      numFrames: totalFrames\n    }\n  };\n} ","/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * チャンネルデータを安全に取得する共通関数\n * @param audio - AudioData オブジェクト\n * @param channel - チャンネル番号 (-1 で全チャンネルの平均)\n * @returns 指定されたチャンネルのデータ\n * @throws AudioInspectError チャンネルが無効な場合\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError(\n            'INVALID_INPUT',\n            `チャンネル ${ch} のデータが存在しません`\n          );\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}。有効範囲は 0-${audio.numberOfChannels - 1} または -1（平均）です`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n\n  return channelData;\n}\n\n/**\n * 数値が2の冪かどうかを判定\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * 次の2の冪を計算\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * 型安全な配列アクセス\n */\nexport function safeArrayAccess<T>(\n  array: ArrayLike<T>,\n  index: number,\n  defaultValue: T\n): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * 数値の妥当性を検証\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * サンプル値の安全な取得\n */\nexport function ensureValidSample(value: number | undefined | null, defaultValue: number = 0): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Float32Arrayの安全な確保\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * 振幅をdBに変換\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n  \n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n  \n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB \n    ? 20 * Math.log10(ratio) \n    : SILENCE_DB;\n}\n\n/**\n * dBを振幅に変換\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n} ","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<void>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n// WebFFT型定義\ninterface WebFFTInstance {\n  fft(input: Float32Array): Float32Array;\n  profile(): Promise<unknown>;\n  dispose(): void;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: WebFFTInstance | null = null;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {}\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const webfftModule = await import('webfft');\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      const WebFFTConstructor = webfftModule.default as any;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      this.fftInstance = new WebFFTConstructor(this.size) as WebFFTInstance;\n\n      if (this.enableProfiling && this.fftInstance?.profile) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<void> {\n    if (!this.fftInstance || !this.fftInstance.profile) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    await this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance && this.fftInstance.dispose) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * 効率的なネイティブFFTプロバイダー（Cooley-Tukey実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  private bitReversalTable!: Uint32Array;\n  private twiddleFactorsReal!: Float32Array;\n  private twiddleFactorsImag!: Float32Array;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        'FFTサイズは2の冪である必要があります'\n      );\n    }\n    this.precomputeTables();\n  }\n\n  get name(): string {\n    return 'Native FFT (Cooley-Tukey)';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  private precomputeTables(): void {\n    // ビット反転テーブルの事前計算\n    this.bitReversalTable = new Uint32Array(this.size);\n    const bits = Math.log2(this.size);\n    for (let i = 0; i < this.size; i++) {\n      let reversed = 0;\n      for (let j = 0; j < bits; j++) {\n        reversed = (reversed << 1) | ((i >> j) & 1);\n      }\n      this.bitReversalTable[i] = reversed;\n    }\n\n    // Twiddle factorsの事前計算\n    const halfSize = this.size / 2;\n    this.twiddleFactorsReal = new Float32Array(halfSize);\n    this.twiddleFactorsImag = new Float32Array(halfSize);\n    for (let i = 0; i < halfSize; i++) {\n      const angle = -2 * Math.PI * i / this.size;\n      this.twiddleFactorsReal[i] = Math.cos(angle);\n      this.twiddleFactorsImag[i] = Math.sin(angle);\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // 複素数配列の初期化（ビット反転順）\n    const real = new Float32Array(this.size);\n    const imag = new Float32Array(this.size);\n    \n    for (let i = 0; i < this.size; i++) {\n      const reversedIndex = this.bitReversalTable[i];\n      if (reversedIndex !== undefined) {\n        real[reversedIndex] = input[i] || 0;\n        imag[reversedIndex] = 0;\n      }\n    }\n\n    // Cooley-Tukey FFTアルゴリズム\n    for (let stage = 1; stage < this.size; stage *= 2) {\n      const stageSize = stage * 2;\n      const twiddleStep = this.size / stageSize;\n      \n      for (let k = 0; k < this.size; k += stageSize) {\n        for (let j = 0; j < stage; j++) {\n          const twiddleIndex = j * twiddleStep;\n          const wr = this.twiddleFactorsReal[twiddleIndex] || 0;\n          const wi = this.twiddleFactorsImag[twiddleIndex] || 0;\n          \n          const evenIndex = k + j;\n          const oddIndex = k + j + stage;\n          \n          const evenReal = real[evenIndex] || 0;\n          const evenImag = imag[evenIndex] || 0;\n          const oddReal = real[oddIndex] || 0;\n          const oddImag = imag[oddIndex] || 0;\n          \n          const tempReal = oddReal * wr - oddImag * wi;\n          const tempImag = oddReal * wi + oddImag * wr;\n          \n          real[evenIndex] = evenReal + tempReal;\n          imag[evenIndex] = evenImag + tempImag;\n          real[oddIndex] = evenReal - tempReal;\n          imag[oddIndex] = evenImag - tempImag;\n        }\n      }\n    }\n\n    // 結果の構築\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < this.size; i++) {\n      complex[i * 2] = real[i] || 0;\n      complex[i * 2 + 1] = imag[i] || 0;\n      \n      if (i <= this.size / 2) {\n        const realPart = real[i] || 0;\n        const imagPart = imag[i] || 0;\n        magnitude[i] = Math.sqrt(realPart * realPart + imagPart * imagPart);\n        phase[i] = Math.atan2(imagPart, realPart);\n        frequencies[i] = (i * this.sampleRate) / this.size;\n      }\n    }\n\n    return { complex, magnitude, phase, frequencies };\n  }\n\n  dispose(): void {\n    // メモリの明示的な解放（必要に応じて）\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft': {\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider.initializeWebFFT();\n        return provider;\n      }\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default: {\n        const exhaustiveCheck: never = config.type;\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${String(exhaustiveCheck)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { FFTProviderFactory, type FFTProviderType, type FFTResult } from '../core/fft-provider.js';\n\n/**\n * FFT分析のオプション\n */\nexport interface FFTOptions {\n  /** FFTサイズ（デフォルト: 2048、2の累乗である必要があります） */\n  fftSize?: number;\n  /** ウィンドウ関数（デフォルト: 'hann'） */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** オーバーラップ率（デフォルト: 0.5） */\n  overlap?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** FFTプロバイダー（デフォルト: 'webfft'） */\n  provider?: FFTProviderType;\n  /** プロファイリングを有効にする（WebFFTのみ） */\n  enableProfiling?: boolean;\n}\n\n/**\n * スペクトラム解析のオプション\n */\nexport interface SpectrumOptions extends FFTOptions {\n  /** 最小周波数（Hz、デフォルト: 0） */\n  minFrequency?: number;\n  /** 最大周波数（Hz、デフォルト: ナイキスト周波数） */\n  maxFrequency?: number;\n  /** dB表示かどうか（デフォルト: true） */\n  decibels?: boolean;\n  /** 時間フレーム数（スペクトログラム用、デフォルト: 100） */\n  timeFrames?: number;\n}\n\n/**\n * スペクトログラムデータ\n */\nexport interface SpectrogramData {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** 周波数軸（Hz） */\n  frequencies: Float32Array;\n  /** 強度データ（時間 x 周波数） */\n  intensities: Float32Array[];\n  /** フレーム数 */\n  timeFrames: number;\n  /** 周波数ビン数 */\n  frequencyBins: number;\n}\n\n/**\n * FFT分析結果\n */\nexport interface FFTAnalysisResult extends FFTResult {\n  /** FFTサイズ */\n  fftSize: number;\n  /** 使用されたウィンドウ関数 */\n  windowFunction: string;\n  /** プロバイダー名 */\n  providerName: string;\n}\n\n/**\n * スペクトラム解析結果\n */\nexport interface SpectrumAnalysisResult {\n  /** 周波数（Hz） */\n  frequencies: Float32Array;\n  /** 強度 */\n  magnitudes: Float32Array;\n  /** dB値（decielsオプションがtrueの場合） */\n  decibels?: Float32Array;\n  /** スペクトログラム（timeFrames > 1の場合） */\n  spectrogram?: SpectrogramData;\n}\n\n/**\n * ウィンドウ関数を適用\n */\nfunction applyWindow(data: Float32Array, windowType: string): Float32Array {\n  const windowed = new Float32Array(data.length);\n  const N = data.length;\n\n  for (let i = 0; i < N; i++) {\n    let windowValue = 1;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n        break;\n      case 'blackman':\n        windowValue =\n          0.42 -\n          0.5 * Math.cos((2 * Math.PI * i) / (N - 1)) +\n          0.08 * Math.cos((4 * Math.PI * i) / (N - 1));\n        break;\n      case 'none':\n      default:\n        windowValue = 1;\n        break;\n    }\n\n    windowed[i] = (data[i] || 0) * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `無効なチャンネル番号: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `チャンネル ${channel} のデータが存在しません`);\n  }\n\n  return channelData;\n}\n\n/**\n * FFT分析を行う\n *\n * @param audio - 音声データ\n * @param options - FFTオプション\n * @returns FFT結果\n */\nexport async function getFFT(\n  audio: AudioData,\n  options: FFTOptions = {}\n): Promise<FFTAnalysisResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    provider = 'webfft',\n    enableProfiling = false\n  } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // FFTサイズが入力より大きい場合、ゼロパディング\n  let inputData: Float32Array;\n  if (channelData.length < fftSize) {\n    inputData = new Float32Array(fftSize);\n    inputData.set(channelData);\n  } else {\n    inputData = channelData.slice(0, fftSize);\n  }\n\n  // ウィンドウ関数を適用\n  const windowedData = applyWindow(inputData, windowFunction);\n\n  // FFTプロバイダーを作成\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: provider,\n    fftSize,\n    sampleRate: audio.sampleRate,\n    enableProfiling\n  });\n\n  try {\n    // FFTを実行\n    const result = fftProvider.fft(windowedData);\n\n    return {\n      ...result,\n      fftSize,\n      windowFunction,\n      providerName: fftProvider.name\n    };\n  } finally {\n    // リソースを解放\n    fftProvider.dispose();\n  }\n}\n\n/**\n * スペクトラム解析を行う\n *\n * @param audio - 音声データ\n * @param options - スペクトラムオプション\n * @returns スペクトラム解析結果\n */\nexport async function getSpectrum(\n  audio: AudioData,\n  options: SpectrumOptions = {}\n): Promise<SpectrumAnalysisResult> {\n  const {\n    fftSize = 2048,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    decibels = true,\n    timeFrames = 1,\n    overlap = 0.5,\n    ...fftOptions\n  } = options;\n\n  const channelData = getChannelData(audio, options.channel || 0);\n\n  if (timeFrames === 1) {\n    // 単一フレームのスペクトラム解析\n    const fftResult = await getFFT(audio, { ...fftOptions, fftSize });\n\n    // 周波数範囲をフィルタリング\n    const filteredResult = filterFrequencyRange(fftResult, minFrequency, maxFrequency);\n\n    const result: SpectrumAnalysisResult = {\n      frequencies: filteredResult.frequencies,\n      magnitudes: filteredResult.magnitude\n    };\n\n    if (decibels) {\n      result.decibels = magnitudeToDecibels(filteredResult.magnitude);\n    }\n\n    return result;\n  } else {\n    // スペクトログラム解析\n    const spectrogram = await computeSpectrogram(\n      channelData,\n      audio.sampleRate,\n      fftSize,\n      timeFrames,\n      overlap,\n      { ...fftOptions, minFrequency, maxFrequency, decibels }\n    );\n\n    return {\n      frequencies: spectrogram.frequencies,\n      magnitudes: new Float32Array(), // スペクトログラムでは個別のmagnitudesは空\n      spectrogram\n    };\n  }\n}\n\n/**\n * 周波数範囲をフィルタリング\n */\nfunction filterFrequencyRange(fftResult: FFTResult, minFreq: number, maxFreq: number): FFTResult {\n  const { frequencies, magnitude, phase, complex } = fftResult;\n\n  const startIndex = frequencies.findIndex((f) => f >= minFreq);\n  const endIndex = frequencies.findIndex((f) => f > maxFreq);\n  const actualEndIndex = endIndex === -1 ? frequencies.length : endIndex;\n\n  return {\n    frequencies: frequencies.slice(startIndex, actualEndIndex),\n    magnitude: magnitude.slice(startIndex, actualEndIndex),\n    phase: phase.slice(startIndex, actualEndIndex),\n    complex: complex.slice(startIndex * 2, actualEndIndex * 2)\n  };\n}\n\n/**\n * 振幅をdBに変換\n */\nfunction magnitudeToDecibels(magnitude: Float32Array): Float32Array {\n  const decibels = new Float32Array(magnitude.length);\n  for (let i = 0; i < magnitude.length; i++) {\n    const mag = magnitude[i] || 0;\n    decibels[i] = mag > 0 ? 20 * Math.log10(mag) : -Infinity;\n  }\n  return decibels;\n}\n\n/**\n * スペクトログラム計算のオプション\n */\ninterface SpectrogramOptions {\n  provider?: FFTProviderType;\n  enableProfiling?: boolean;\n  windowFunction?: string;\n  minFrequency?: number;\n  maxFrequency?: number;\n  decibels?: boolean;\n}\n\n/**\n * スペクトログラムを計算\n */\nasync function computeSpectrogram(\n  data: Float32Array,\n  sampleRate: number,\n  fftSize: number,\n  timeFrames: number,\n  overlap: number,\n  options: SpectrogramOptions\n): Promise<SpectrogramData> {\n  const hopSize = Math.floor(fftSize * (1 - overlap));\n  const actualFrames = Math.min(timeFrames, Math.floor((data.length - fftSize) / hopSize) + 1);\n\n  const times = new Float32Array(actualFrames);\n  const intensities: Float32Array[] = [];\n  let frequencies: Float32Array = new Float32Array();\n\n  // FFTプロバイダーを作成（一度だけ）\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: options.provider || 'webfft',\n    fftSize,\n    sampleRate,\n    enableProfiling: options.enableProfiling || false\n  });\n\n  try {\n    for (let frame = 0; frame < actualFrames; frame++) {\n      const startSample = frame * hopSize;\n\n      // フレームデータを抽出\n      const frameData = new Float32Array(fftSize);\n      for (let i = 0; i < fftSize && startSample + i < data.length; i++) {\n        frameData[i] = data[startSample + i] || 0;\n      }\n\n      // ウィンドウ関数を適用\n      const windowedData = applyWindow(frameData, options.windowFunction || 'hann');\n\n      // FFTを実行\n      const fftResult = fftProvider.fft(windowedData);\n\n      // 最初のフレームで周波数軸を設定\n      if (frame === 0) {\n        frequencies = fftResult.frequencies;\n      }\n\n      // 強度データを保存\n      const magnitude = fftResult.magnitude;\n      const frameIntensity = options.decibels ? magnitudeToDecibels(magnitude) : magnitude;\n      intensities.push(frameIntensity);\n\n      // 時間位置を計算\n      times[frame] = (startSample + fftSize / 2) / sampleRate;\n    }\n  } finally {\n    fftProvider.dispose();\n  }\n\n  return {\n    times,\n    frequencies,\n    intensities,\n    timeFrames: actualFrames,\n    frequencyBins: frequencies.length\n  };\n}\n"],"mappings":"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","names":["channelData"]}