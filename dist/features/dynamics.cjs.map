{"version":3,"sources":["../../src/features/dynamics.ts","../../src/types.ts","../../src/core/utils.ts","../../src/features/time.ts"],"sourcesContent":["import { AudioData, AudioInspectError, AmplitudeOptions } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\nimport { getRMS, getPeakAmplitude } from './time.js';\n\nexport interface CrestFactorOptions {\n  channel?: number;\n  windowSize?: number; // 窓サイズ（秒）\n  hopSize?: number; // ホップサイズ（秒）\n  method?: 'simple' | 'weighted'; // 重み付きクレストファクター\n}\n\nexport interface CrestFactorResult {\n  crestFactor: number; // 全体のクレストファクター (dB)\n  crestFactorLinear: number; // 線形スケールのクレストファクター\n  peak: number; // ピーク値（線形）\n  rms: number; // RMS値（線形）\n  timeVarying?:\n    | {\n        times: Float32Array;\n        values: Float32Array; // dB\n        valuesLinear: Float32Array; // 線形\n        peaks: Float32Array;\n        rmsValues: Float32Array;\n      }\n    | undefined;\n}\n\nfunction calculateFrameCrestFactor(\n  frameData: Float32Array,\n  method: 'simple' | 'weighted' = 'simple'\n): { peak: number; rms: number; cfDb: number; cfLinear: number } {\n  if (frameData.length === 0) {\n    return { peak: 0, rms: 0, cfDb: -Infinity, cfLinear: 0 };\n  }\n\n  let processedData = frameData;\n\n  // 重み付き処理（オプション）\n  if (method === 'weighted') {\n    // A-weightingの簡易実装\n    // 実際にはIIRフィルタで実装すべき\n    processedData = frameData; // プレースホルダー\n  }\n\n  let peakVal = 0;\n  let sumOfSquares = 0;\n  let validSamples = 0;\n\n  for (let i = 0; i < processedData.length; i++) {\n    const sample = ensureValidSample(processedData[i]);\n    const absSample = Math.abs(sample);\n\n    peakVal = Math.max(peakVal, absSample);\n    sumOfSquares += sample * sample;\n    validSamples++;\n  }\n\n  if (validSamples === 0) {\n    return { peak: 0, rms: 0, cfDb: -Infinity, cfLinear: 0 };\n  }\n\n  const rmsVal = Math.sqrt(sumOfSquares / validSamples);\n\n  if (rmsVal < 1e-10) {\n    return { peak: peakVal, rms: rmsVal, cfDb: Infinity, cfLinear: Infinity };\n  }\n\n  const cfLinear = peakVal / rmsVal;\n  const cfDb = 20 * Math.log10(cfLinear);\n\n  return { peak: peakVal, rms: rmsVal, cfDb, cfLinear };\n}\n\nexport function getCrestFactor(\n  audio: AudioData,\n  options: CrestFactorOptions = {}\n): CrestFactorResult {\n  const { channel = 0, windowSize, hopSize, method = 'simple' } = options;\n\n  // 全体のクレストファクター計算\n  const amplitudeOpts: AmplitudeOptions = { channel, asDB: false };\n  const overallPeak = getPeakAmplitude(audio, amplitudeOpts);\n  const overallRms = getRMS(audio, amplitudeOpts);\n\n  const overallCfLinear = overallRms > 1e-10 ? overallPeak / overallRms : Infinity;\n  const overallCfDb = overallRms > 1e-10 ? 20 * Math.log10(overallCfLinear) : Infinity;\n\n  let timeVaryingResult: CrestFactorResult['timeVarying'] | undefined;\n\n  // 時変クレストファクター計算\n  if (typeof windowSize === 'number' && typeof hopSize === 'number') {\n    if (windowSize <= 0 || hopSize <= 0) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        'windowSizeとhopSizeは正の値である必要があります'\n      );\n    }\n\n    if (hopSize > windowSize) {\n      console.warn(\n        '[audio-inspect] hopSizeがwindowSizeより大きいため、分析窓間にギャップが生じます'\n      );\n    }\n\n    const windowSizeSamples = Math.floor(windowSize * audio.sampleRate);\n    const hopSizeSamples = Math.floor(hopSize * audio.sampleRate);\n\n    if (windowSizeSamples === 0 || hopSizeSamples === 0) {\n      throw new AudioInspectError('INVALID_INPUT', 'サンプルレートに対して窓サイズが小さすぎます');\n    }\n\n    const channelData = getChannelData(audio, channel);\n    const dataLength = channelData.length;\n\n    if (dataLength < windowSizeSamples) {\n      // データが1窓分に満たない場合\n      const result = calculateFrameCrestFactor(channelData, method);\n      timeVaryingResult = {\n        times: new Float32Array([audio.duration / 2]),\n        values: new Float32Array([result.cfDb]),\n        valuesLinear: new Float32Array([result.cfLinear]),\n        peaks: new Float32Array([result.peak]),\n        rmsValues: new Float32Array([result.rms])\n      };\n    } else {\n      const frameCount = Math.floor((dataLength - windowSizeSamples) / hopSizeSamples) + 1;\n      const times = new Float32Array(frameCount);\n      const values = new Float32Array(frameCount);\n      const valuesLinear = new Float32Array(frameCount);\n      const peaks = new Float32Array(frameCount);\n      const rmsValues = new Float32Array(frameCount);\n\n      for (let i = 0; i < frameCount; i++) {\n        const start = i * hopSizeSamples;\n        const end = Math.min(start + windowSizeSamples, dataLength);\n        const frameData = channelData.subarray(start, end);\n\n        const frameResult = calculateFrameCrestFactor(frameData, method);\n\n        times[i] = (start + windowSizeSamples / 2) / audio.sampleRate;\n        values[i] = frameResult.cfDb;\n        valuesLinear[i] = frameResult.cfLinear;\n        peaks[i] = frameResult.peak;\n        rmsValues[i] = frameResult.rms;\n      }\n\n      timeVaryingResult = { times, values, valuesLinear, peaks, rmsValues };\n    }\n  }\n\n  return {\n    crestFactor: overallCfDb,\n    crestFactorLinear: overallCfLinear,\n    peak: overallPeak,\n    rms: overallRms,\n    timeVarying: timeVaryingResult\n  };\n}\n","/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * フォールバック機能付きストリーミングオプション\n */\nexport interface StreamOptionsWithFallback extends StreamOptions {\n  /** フォールバック処理を有効にするか */\n  enableFallback?: boolean;\n  /** フォールバック時のハンドラー */\n  fallbackHandler?: (audio: AudioData) => void;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED'\n  | 'WORKLET_NOT_SUPPORTED' // AudioWorkletサポートなし\n  | 'MODULE_LOAD_FAILED'; // モジュール読み込み失敗\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage\n  | CleanupMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * クリーンアップメッセージ\n */\nexport interface CleanupMessage {\n  type: 'cleanup';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n","import { AudioData, AmplitudeOptions, AudioInspectError } from '../types.js';\nimport {\n  getChannelData,\n  ensureValidSample,\n  isValidSample,\n  amplitudeToDecibels,\n  safeArrayAccess\n} from '../core/utils.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\ninterface PeakCandidate {\n  position: number;\n  amplitude: number;\n  prominence?: number; // ピークの顕著性（オプション）\n}\n\n// より洗練されたピーク検出アルゴリズム\nfunction detectAllInitialPeaks(\n  data: Float32Array,\n  threshold: number,\n  includeProminence: boolean = false\n): PeakCandidate[] {\n  const peaks: PeakCandidate[] = [];\n  const length = data.length;\n\n  if (length < 3) return peaks; // 最低3サンプル必要\n\n  for (let i = 1; i < length - 1; i++) {\n    const current = Math.abs(ensureValidSample(data[i]));\n    const prev = Math.abs(ensureValidSample(data[i - 1]));\n    const next = Math.abs(ensureValidSample(data[i + 1]));\n\n    // ローカルマキシマムかつ閾値を超えているか\n    if (current > prev && current > next && current > threshold) {\n      const peak: PeakCandidate = {\n        position: i,\n        amplitude: current\n      };\n\n      // オプション：ピークの顕著性を計算\n      if (includeProminence) {\n        peak.prominence = calculateProminence(data, i, current);\n      }\n\n      peaks.push(peak);\n    }\n  }\n\n  return peaks;\n}\n\n// ピークの顕著性を計算（オプション機能）\nfunction calculateProminence(data: Float32Array, peakIndex: number, peakValue: number): number {\n  // 左側の最小値を探索\n  let leftMin = peakValue;\n  for (let i = peakIndex - 1; i >= 0; i--) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    leftMin = Math.min(leftMin, value);\n  }\n\n  // 右側の最小値を探索\n  let rightMin = peakValue;\n  for (let i = peakIndex + 1; i < data.length; i++) {\n    const value = Math.abs(ensureValidSample(data[i]));\n    if (value > peakValue) break; // より高いピークに到達\n    rightMin = Math.min(rightMin, value);\n  }\n\n  return peakValue - Math.max(leftMin, rightMin);\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100) // デフォルト10ms\n  } = options;\n\n  if (count <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'ピーク数は正の整数である必要があります');\n  }\n\n  if (threshold < 0 || threshold > 1) {\n    throw new AudioInspectError('INVALID_INPUT', '閾値は0から1の範囲である必要があります');\n  }\n\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 1. すべての初期ピーク候補を検出\n  const allInitialPeaks = detectAllInitialPeaks(channelData, threshold);\n\n  if (allInitialPeaks.length === 0) {\n    return {\n      peaks: [],\n      maxAmplitude: 0,\n      averageAmplitude: 0\n    };\n  }\n\n  // 2. 振幅の降順でソート\n  allInitialPeaks.sort((a, b) => b.amplitude - a.amplitude);\n\n  // 3. 空間的フィルタリング（最小距離制約）\n  const selectedPeaks: Peak[] = [];\n  const occupiedRegions: Array<[number, number]> = []; // [start, end]の配列\n\n  for (const candidate of allInitialPeaks) {\n    if (selectedPeaks.length >= count) break;\n\n    // 占有領域との重複をチェック\n    const candidateStart = candidate.position - minDistance;\n    const candidateEnd = candidate.position + minDistance;\n\n    const hasOverlap = occupiedRegions.some(\n      ([start, end]) => !(candidateEnd < start || candidateStart > end)\n    );\n\n    if (!hasOverlap) {\n      selectedPeaks.push({\n        position: candidate.position,\n        time: candidate.position / audio.sampleRate,\n        amplitude: candidate.amplitude\n      });\n\n      occupiedRegions.push([candidateStart, candidateEnd]);\n    }\n  }\n\n  // 4. 時間順でソート\n  selectedPeaks.sort((a, b) => a.position - b.position);\n\n  // 5. 統計情報の計算（すべての候補から）\n  const maxAmplitude = allInitialPeaks.length > 0 ? (allInitialPeaks[0]?.amplitude ?? 0) : 0;\n  const averageAmplitude =\n    allInitialPeaks.length > 0\n      ? allInitialPeaks.reduce((sum, p) => sum + p.amplitude, 0) / allInitialPeaks.length\n      : 0;\n\n  return {\n    peaks: selectedPeaks,\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n// 定数定義\nconst SILENCE_DB = -Infinity;\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(audio: AudioData, optionsOrChannel: AmplitudeOptions | number = {}): number {\n  const options: Required<AmplitudeOptions> =\n    typeof optionsOrChannel === 'number'\n      ? { channel: optionsOrChannel, asDB: false, reference: 1.0 }\n      : {\n          channel: 0,\n          asDB: false,\n          reference: 1.0,\n          ...optionsOrChannel\n        };\n\n  const channelData = getChannelData(audio, options.channel);\n\n  if (channelData.length === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  // RMS計算（数値的安定性を考慮）\n  let sumOfSquares = 0;\n  let validSampleCount = 0;\n\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      sumOfSquares += sample * sample;\n      validSampleCount++;\n    }\n  }\n\n  if (validSampleCount === 0) {\n    return options.asDB ? SILENCE_DB : 0;\n  }\n\n  const rms = Math.sqrt(sumOfSquares / validSampleCount);\n\n  return options.asDB ? amplitudeToDecibels(rms, options.reference) : rms;\n}\n\n/**\n * ピーク振幅を計算\n */\nexport function getPeakAmplitude(audio: AudioData, options: AmplitudeOptions = {}): number {\n  const resolvedOptions: Required<AmplitudeOptions> = {\n    channel: 0,\n    asDB: false,\n    reference: 1.0,\n    ...options\n  };\n\n  const channelData = getChannelData(audio, resolvedOptions.channel);\n\n  if (channelData.length === 0) {\n    return resolvedOptions.asDB ? SILENCE_DB : 0;\n  }\n\n  let peak = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i];\n    if (isValidSample(sample)) {\n      peak = Math.max(peak, Math.abs(sample));\n    }\n  }\n\n  return resolvedOptions.asDB ? amplitudeToDecibels(peak, resolvedOptions.reference) : peak;\n}\n\n// エイリアスとしてgetPeakをエクスポート\nexport { getPeakAmplitude as getPeak };\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  if (channelData.length < 2) {\n    return 0;\n  }\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = ensureValidSample(channelData[i - 1]);\n    const current = ensureValidSample(channelData[i]);\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number; // nullを許容しない設計\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  const channelData = getChannelData(audio, channel);\n\n  // 修正2.3: 極端なフレーム数指定時の不具合対応\n  // audio.length が0の場合は frameCount も0にする\n  const desiredFrameCount = Math.ceil(audio.duration * framesPerSecond);\n  const maxPossibleFrameCount = audio.length > 0 ? audio.length : desiredFrameCount > 0 ? 1 : 0;\n  const frameCount = Math.min(desiredFrameCount, maxPossibleFrameCount);\n\n  const samplesPerFrame = frameCount > 0 ? Math.max(1, Math.floor(audio.length / frameCount)) : 0;\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム長が0または負の場合の処理\n    if (endSample <= startSample) {\n      // 最後の有効な振幅値を使用、または0\n      const lastAmplitude =\n        waveform.length > 0\n          ? safeArrayAccess(waveform, waveform.length - 1, { time: 0, amplitude: 0 }).amplitude\n          : 0;\n\n      waveform.push({\n        time: (startSample + samplesPerFrame / 2) / audio.sampleRate,\n        amplitude: lastAmplitude\n      });\n      continue;\n    }\n\n    // フレームデータの処理\n    const frameData = channelData.subarray(startSample, endSample); // sliceより効率的\n\n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n    waveform.push({ time, amplitude });\n\n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = ensureValidSample(frameData[i]);\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(ensureValidSample(frameData[i]));\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  if (frameData.length === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(ensureValidSample(frameData[i]));\n  }\n  return sum / frameData.length;\n}\n"],"mappings":"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","names":["channelData","SILENCE_DB"]}