{"version":3,"sources":["../../src/features/energy.ts","../../src/types.ts","../../src/core/utils.ts"],"sourcesContent":["import { AudioData, AudioInspectError } from '../types.js';\nimport { getChannelData, ensureValidSample } from '../core/utils.js';\n\nexport interface EnergyOptions {\n  frameSize?: number;\n  hopSize?: number;\n  channel?: number;\n  normalized?: boolean;\n  windowFunction?: 'rectangular' | 'hann' | 'hamming'; // エネルギー計算用の窓関数\n}\n\nexport interface EnergyResult {\n  times: Float32Array;\n  energies: Float32Array;\n  totalEnergy: number;\n  statistics: {\n    mean: number;\n    std: number;\n    max: number;\n    min: number;\n  };\n}\n\n// 窓関数の適用（エネルギー計算用）\nfunction applyEnergyWindow(\n  data: Float32Array,\n  windowType: string,\n  startIdx: number,\n  length: number\n): Float32Array {\n  const windowed = new Float32Array(length);\n  \n  for (let i = 0; i < length && startIdx + i < data.length; i++) {\n    let windowValue = 1.0;\n    \n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (length - 1));\n        break;\n      case 'rectangular':\n      default:\n        windowValue = 1.0;\n    }\n    \n    const sample = ensureValidSample(data[startIdx + i]);\n    windowed[i] = sample * windowValue;\n  }\n  \n  return windowed;\n}\n\nexport function getEnergy(\n  audio: AudioData,\n  options: EnergyOptions = {}\n): EnergyResult {\n  const {\n    frameSize = Math.floor(audio.sampleRate * 0.025), // 25ms\n    hopSize = Math.floor(audio.sampleRate * 0.010),   // 10ms\n    channel = 0,\n    normalized = false,\n    windowFunction = 'rectangular'\n  } = options;\n\n  // パラメータの検証\n  if (frameSize <= 0 || !Number.isInteger(frameSize)) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      'frameSizeは正の整数である必要があります'\n    );\n  }\n\n  if (hopSize <= 0 || !Number.isInteger(hopSize)) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      'hopSizeは正の整数である必要があります'\n    );\n  }\n\n  if (hopSize > frameSize) {\n    console.warn('[audio-inspect] hopSizeがframeSizeより大きいため、フレーム間にギャップが生じます');\n  }\n\n  const channelData = getChannelData(audio, channel);\n  const dataLength = channelData.length;\n\n  if (dataLength === 0) {\n    return {\n      times: new Float32Array(0),\n      energies: new Float32Array(0),\n      totalEnergy: 0,\n      statistics: { mean: 0, std: 0, max: 0, min: 0 }\n    };\n  }\n\n  // フレーム数の計算\n  const frameCount = Math.max(0, Math.floor((dataLength - frameSize) / hopSize) + 1);\n  \n  if (frameCount === 0) {\n    // データが1フレーム分に満たない場合\n    const energy = calculateFrameEnergy(channelData, 0, dataLength, windowFunction);\n    return {\n      times: new Float32Array([dataLength / 2 / audio.sampleRate]),\n      energies: new Float32Array([energy]),\n      totalEnergy: energy,\n      statistics: { mean: energy, std: 0, max: energy, min: energy }\n    };\n  }\n\n  const times = new Float32Array(frameCount);\n  const energies = new Float32Array(frameCount);\n  let totalEnergy = 0;\n  let maxEnergy = -Infinity;\n  let minEnergy = Infinity;\n\n  // 各フレームのエネルギー計算\n  for (let i = 0; i < frameCount; i++) {\n    const start = i * hopSize;\n    const windowedFrame = applyEnergyWindow(channelData, windowFunction, start, frameSize);\n    \n    let frameEnergy = 0;\n    for (let j = 0; j < windowedFrame.length; j++) {\n      const sample = windowedFrame[j];\n      if (sample !== undefined) {\n        frameEnergy += sample * sample;\n      }\n    }\n\n    times[i] = (start + frameSize / 2) / audio.sampleRate;\n    energies[i] = frameEnergy;\n    totalEnergy += frameEnergy;\n    \n    maxEnergy = Math.max(maxEnergy, frameEnergy);\n    minEnergy = Math.min(minEnergy, frameEnergy);\n  }\n\n  // 統計情報の計算\n  const meanEnergy = totalEnergy / frameCount;\n  let varianceSum = 0;\n  \n  for (let i = 0; i < frameCount; i++) {\n    const energy = energies[i];\n    if (energy !== undefined) {\n      const diff = energy - meanEnergy;\n      varianceSum += diff * diff;\n    }\n  }\n  \n  const stdEnergy = Math.sqrt(varianceSum / frameCount);\n\n  // 正規化（オプション）\n  if (normalized && totalEnergy > 1e-10) {\n    for (let i = 0; i < energies.length; i++) {\n      const currentEnergy = energies[i];\n      if (currentEnergy !== undefined) {\n        energies[i] = currentEnergy / totalEnergy;\n      }\n    }\n    \n    return {\n      times,\n      energies,\n      totalEnergy: 1.0,\n      statistics: {\n        mean: meanEnergy / totalEnergy,\n        std: stdEnergy / totalEnergy,\n        max: maxEnergy / totalEnergy,\n        min: minEnergy / totalEnergy\n      }\n    };\n  }\n\n  return {\n    times,\n    energies,\n    totalEnergy,\n    statistics: {\n      mean: meanEnergy,\n      std: stdEnergy,\n      max: maxEnergy,\n      min: minEnergy\n    }\n  };\n}\n\n// ヘルパー関数\nfunction calculateFrameEnergy(\n  data: Float32Array,\n  start: number,\n  length: number,\n  windowFunction: string\n): number {\n  const windowed = applyEnergyWindow(data, windowFunction, start, length);\n  let energy = 0;\n  for (const sample of windowed) {\n    energy += sample * sample;\n  }\n  return energy;\n} ","/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * チャンネルデータを安全に取得する共通関数\n * @param audio - AudioData オブジェクト\n * @param channel - チャンネル番号 (-1 で全チャンネルの平均)\n * @returns 指定されたチャンネルのデータ\n * @throws AudioInspectError チャンネルが無効な場合\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError(\n            'INVALID_INPUT',\n            `チャンネル ${ch} のデータが存在しません`\n          );\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `無効なチャンネル番号: ${channel}。有効範囲は 0-${audio.numberOfChannels - 1} または -1（平均）です`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `チャンネル ${channel} のデータが存在しません`\n    );\n  }\n\n  return channelData;\n}\n\n/**\n * 数値が2の冪かどうかを判定\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * 次の2の冪を計算\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * 型安全な配列アクセス\n */\nexport function safeArrayAccess<T>(\n  array: ArrayLike<T>,\n  index: number,\n  defaultValue: T\n): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * 数値の妥当性を検証\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * サンプル値の安全な取得\n */\nexport function ensureValidSample(value: number | undefined | null, defaultValue: number = 0): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Float32Arrayの安全な確保\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * 振幅をdBに変換\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n  \n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n  \n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB \n    ? 20 * Math.log10(ratio) \n    : SILENCE_DB;\n}\n\n/**\n * dBを振幅に変換\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n} "],"mappings":"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","names":["channelData"]}