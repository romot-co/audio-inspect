{"version":3,"sources":["../../src/features/stereo.ts","../../src/types.ts","../../src/core/fft-provider.ts","../../src/features/frequency.ts","../../src/core/utils.ts"],"sourcesContent":["import { AudioData, AudioInspectError } from '../types.js';\nimport { getFFT } from './frequency.js';\nimport { ensureValidSample } from '../core/utils.js';\n\nexport interface StereoAnalysisOptions {\n  frameSize?: number; // 分析フレームサイズ（サンプル数）\n  hopSize?: number; // ホップサイズ（サンプル数）\n  calculatePhase?: boolean; // 位相解析を行うか\n  calculateITD?: boolean; // 両耳間時間差を計算するか\n  calculateILD?: boolean; // 両耳間レベル差を計算するか\n}\n\nexport interface StereoAnalysisResult {\n  correlation: number; // 相関係数 (-1 to 1)\n  coherence?: Float32Array; // 周波数別コヒーレンス\n  width: number; // ステレオ幅 (0 to 1)\n  widthFrequency?: Float32Array; // 周波数別ステレオ幅\n  balance: number; // L/R バランス (-1 to 1)\n  phaseDifference?: number; // 平均位相差（度）\n  phaseCorrelation?: number; // 位相相関 (-1 to 1)\n  midSideRatio: number; // Mid/Side エネルギー比 (dB)\n  itd?: number; // 両耳間時間差 (ms)\n  ild?: number; // 両耳間レベル差 (dB)\n  goniometer?: {\n    // ゴニオメーター用データ\n    x: Float32Array; // L-R (Side)\n    y: Float32Array; // L+R (Mid)\n  };\n}\n\n// クロス相関による遅延推定\nfunction estimateDelay(\n  left: Float32Array,\n  right: Float32Array,\n  maxDelaySamples: number = 44\n): number {\n  const len = Math.min(left.length, right.length);\n  let maxCorr = -Infinity;\n  let bestDelay = 0;\n\n  for (let delay = -maxDelaySamples; delay <= maxDelaySamples; delay++) {\n    let correlation = 0;\n    let count = 0;\n\n    for (let i = 0; i < len; i++) {\n      const leftIdx = i;\n      const rightIdx = i + delay;\n\n      if (rightIdx >= 0 && rightIdx < len) {\n        const leftSample = ensureValidSample(left[leftIdx]);\n        const rightSample = ensureValidSample(right[rightIdx]);\n        correlation += leftSample * rightSample;\n        count++;\n      }\n    }\n\n    if (count > 0) {\n      correlation /= count;\n      if (correlation > maxCorr) {\n        maxCorr = correlation;\n        bestDelay = delay;\n      }\n    }\n  }\n\n  return bestDelay;\n}\n\n// コヒーレンス計算\nasync function calculateCoherence(\n  left: Float32Array,\n  right: Float32Array,\n  fftSize: number,\n  sampleRate: number\n): Promise<Float32Array> {\n  const leftFFT = await getFFT(\n    {\n      channelData: [left],\n      sampleRate,\n      numberOfChannels: 1,\n      length: left.length,\n      duration: left.length / sampleRate\n    },\n    { fftSize }\n  );\n\n  const rightFFT = await getFFT(\n    {\n      channelData: [right],\n      sampleRate,\n      numberOfChannels: 1,\n      length: right.length,\n      duration: right.length / sampleRate\n    },\n    { fftSize }\n  );\n\n  const coherence = new Float32Array(leftFFT.magnitude.length);\n\n  for (let i = 0; i < coherence.length; i++) {\n    const leftMag = leftFFT.magnitude[i] || 0;\n    const rightMag = rightFFT.magnitude[i] || 0;\n    const leftPhase = leftFFT.phase[i] || 0;\n    const rightPhase = rightFFT.phase[i] || 0;\n\n    // クロススペクトル\n    const crossReal = leftMag * rightMag * Math.cos(leftPhase - rightPhase);\n    const crossImag = leftMag * rightMag * Math.sin(leftPhase - rightPhase);\n    const crossMag = Math.sqrt(crossReal * crossReal + crossImag * crossImag);\n\n    // コヒーレンス = |Pxy|^2 / (Pxx * Pyy)\n    const denominator = leftMag * leftMag * rightMag * rightMag;\n    coherence[i] = denominator > 1e-10 ? (crossMag * crossMag) / denominator : 0;\n  }\n\n  return coherence;\n}\n\n// 周波数別ステレオ幅\nfunction calculateFrequencyWidth(\n  leftMag: Float32Array,\n  rightMag: Float32Array,\n  leftPhase: Float32Array,\n  rightPhase: Float32Array\n): Float32Array {\n  const width = new Float32Array(leftMag.length);\n\n  for (let i = 0; i < width.length; i++) {\n    const lMag = leftMag[i] || 0;\n    const rMag = rightMag[i] || 0;\n    const lPhase = leftPhase[i] || 0;\n    const rPhase = rightPhase[i] || 0;\n    const phaseDiff = lPhase - rPhase;\n\n    // M/S変換\n    const midMag = Math.abs(lMag + rMag) / 2;\n    const sideMag = Math.abs(lMag - rMag) / 2;\n\n    // 位相差も考慮したステレオ幅\n    const phaseWidth = Math.abs(Math.sin(phaseDiff / 2));\n    const magWidth = sideMag / (midMag + sideMag + 1e-10);\n\n    width[i] = Math.max(magWidth, phaseWidth);\n  }\n\n  return width;\n}\n\nexport async function getStereoAnalysis(\n  audio: AudioData,\n  options: StereoAnalysisOptions = {}\n): Promise<StereoAnalysisResult> {\n  if (audio.numberOfChannels < 2) {\n    throw new AudioInspectError('INVALID_INPUT', 'ステレオ解析には2チャンネル以上の音声が必要です');\n  }\n\n  const {\n    frameSize = audio.length,\n    calculatePhase = true,\n    calculateITD = true,\n    calculateILD = true\n  } = options;\n\n  const left = audio.channelData[0];\n  const right = audio.channelData[1];\n\n  if (!left || !right) {\n    throw new AudioInspectError('INVALID_INPUT', 'L/Rチャンネルのデータが存在しません');\n  }\n\n  const len = Math.min(left.length, right.length);\n\n  if (len === 0) {\n    return {\n      correlation: 0,\n      width: 0,\n      balance: 0,\n      midSideRatio: 0\n    };\n  }\n\n  // 基本的な統計量の計算\n  let sumL = 0,\n    sumR = 0,\n    sumLR = 0,\n    sumL2 = 0,\n    sumR2 = 0;\n  let energyL = 0,\n    energyR = 0;\n\n  for (let i = 0; i < len; i++) {\n    const l = ensureValidSample(left[i]);\n    const r = ensureValidSample(right[i]);\n\n    sumL += l;\n    sumR += r;\n    sumLR += l * r;\n    sumL2 += l * l;\n    sumR2 += r * r;\n\n    energyL += l * l;\n    energyR += r * r;\n  }\n\n  // 相関係数\n  const meanL = sumL / len;\n  const meanR = sumR / len;\n  const covariance = sumLR / len - meanL * meanR;\n  const stdL = Math.sqrt(sumL2 / len - meanL * meanL);\n  const stdR = Math.sqrt(sumR2 / len - meanR * meanR);\n  const correlation = stdL > 1e-10 && stdR > 1e-10 ? covariance / (stdL * stdR) : 0;\n\n  // Mid/Side処理\n  const mid = new Float32Array(len);\n  const side = new Float32Array(len);\n  let energyMid = 0,\n    energySide = 0;\n\n  for (let i = 0; i < len; i++) {\n    const l = ensureValidSample(left[i]);\n    const r = ensureValidSample(right[i]);\n\n    mid[i] = (l + r) * 0.5;\n    side[i] = (l - r) * 0.5;\n\n    energyMid += (mid[i] ?? 0) * (mid[i] ?? 0);\n    energySide += (side[i] ?? 0) * (side[i] ?? 0);\n  }\n\n  // メトリクスの計算\n  const width = energyMid + energySide > 1e-10 ? energySide / (energyMid + energySide) : 0;\n\n  const balance = energyL + energyR > 1e-10 ? (energyR - energyL) / (energyL + energyR) : 0;\n\n  const midSideRatio = energySide > 1e-10 ? 10 * Math.log10(energyMid / energySide) : Infinity;\n\n  const result: StereoAnalysisResult = {\n    correlation,\n    width,\n    balance,\n    midSideRatio\n  };\n\n  // 位相解析（オプション）\n  if (calculatePhase && frameSize < audio.length) {\n    const fftSize = Math.pow(2, Math.ceil(Math.log2(frameSize)));\n\n    // コヒーレンス計算\n    result.coherence = await calculateCoherence(\n      left.subarray(0, frameSize),\n      right.subarray(0, frameSize),\n      fftSize,\n      audio.sampleRate\n    );\n\n    // 周波数別解析\n    const leftFFT = await getFFT(\n      {\n        channelData: [left.subarray(0, frameSize)],\n        sampleRate: audio.sampleRate,\n        numberOfChannels: 1,\n        length: frameSize,\n        duration: frameSize / audio.sampleRate\n      },\n      { fftSize }\n    );\n\n    const rightFFT = await getFFT(\n      {\n        channelData: [right.subarray(0, frameSize)],\n        sampleRate: audio.sampleRate,\n        numberOfChannels: 1,\n        length: frameSize,\n        duration: frameSize / audio.sampleRate\n      },\n      { fftSize }\n    );\n\n    // 周波数別ステレオ幅\n    result.widthFrequency = calculateFrequencyWidth(\n      leftFFT.magnitude,\n      rightFFT.magnitude,\n      leftFFT.phase,\n      rightFFT.phase\n    );\n\n    // 平均位相差\n    let phaseDiffSum = 0;\n    let weightSum = 0;\n\n    for (let i = 1; i < leftFFT.phase.length; i++) {\n      // DC成分を除外\n      const leftMag = leftFFT.magnitude[i] || 0;\n      const rightMag = rightFFT.magnitude[i] || 0;\n      const leftPhase = leftFFT.phase[i] || 0;\n      const rightPhase = rightFFT.phase[i] || 0;\n\n      const weight = leftMag * rightMag;\n      let phaseDiff = leftPhase - rightPhase;\n\n      // 位相差を -π から π の範囲に正規化\n      while (phaseDiff > Math.PI) phaseDiff -= 2 * Math.PI;\n      while (phaseDiff < -Math.PI) phaseDiff += 2 * Math.PI;\n\n      phaseDiffSum += phaseDiff * weight;\n      weightSum += weight;\n    }\n\n    result.phaseDifference = weightSum > 1e-10 ? ((phaseDiffSum / weightSum) * 180) / Math.PI : 0;\n  }\n\n  // ITD（両耳間時間差）計算（オプション）\n  if (calculateITD) {\n    const delaySamples = estimateDelay(left, right);\n    result.itd = (delaySamples / audio.sampleRate) * 1000; // ms\n  }\n\n  // ILD（両耳間レベル差）計算（オプション）\n  if (calculateILD) {\n    const rmsL = Math.sqrt(energyL / len);\n    const rmsR = Math.sqrt(energyR / len);\n\n    result.ild = rmsL > 1e-10 && rmsR > 1e-10 ? 20 * Math.log10(rmsR / rmsL) : 0;\n  }\n\n  // ゴニオメーター用データ（Lissajous表示）\n  result.goniometer = {\n    x: side, // L-R\n    y: mid // L+R\n  };\n\n  return result;\n}\n\n// 時系列ステレオ解析（将来の拡張用）\nexport function getTimeVaryingStereoAnalysis(\n  _audio: AudioData,\n  _options: StereoAnalysisOptions & { windowSize?: number } = {}\n): Promise<{\n  times: Float32Array;\n  correlation: Float32Array;\n  width: Float32Array;\n  balance: Float32Array;\n}> {\n  return Promise.reject(\n    new AudioInspectError(\n      'UNSUPPORTED_FORMAT',\n      '時系列ステレオ解析は将来のバージョンで実装予定です'\n    )\n  );\n}\n","/**\n * audio-inspect ライブラリの型定義\n */\n\nimport type { FFTProviderType } from './core/fft-provider.js';\n\n/**\n * 音声ソースの型定義\n */\nexport type AudioSource =\n  | ArrayBuffer\n  | Blob\n  | File\n  | URL\n  | string // URLパス\n  | MediaStream\n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Feature<T> = (audio: AudioData, ...args: any[]) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n  /** AudioInspectProcessorのモジュールURL（フル機能版を使用する場合） */\n  processorModuleUrl?: string;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hann' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * 振幅測定のオプション\n */\nexport interface AmplitudeOptions {\n  channel?: number;\n  asDB?: boolean;\n  reference?: number; // dB計算の基準値（デフォルト: 1.0 = 0 dBFS）\n}\n\n/**\n * 共通の解析オプション\n */\nexport interface CommonAnalysisOptions {\n  channel?: number;\n}\n\n/**\n * 時間窓パラメータ\n */\nexport interface TimeWindowOptions {\n  windowSizeMs?: number;\n  hopSizeMs?: number;\n}\n\n/**\n * 周波数範囲パラメータ\n */\nexport interface FrequencyRangeOptions {\n  minFrequency?: number;\n  maxFrequency?: number;\n}\n\n/**\n * Nullable型の明示的な定義\n */\nexport type NullableNumber = number | null;\nexport type NullableFloat32Array = Float32Array | null;\n\n/**\n * 結果型（エラー処理用）\n */\nexport type Result<T, E = AudioInspectError> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\n/**\n * エラーコード\n */\nexport type ErrorCode =\n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT'\n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR'\n  | 'INITIALIZATION_FAILED';\n\n/**\n * Audio-inspect specific error\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n}\n\n/**\n * AudioInspectNodeのオプション\n */\nexport interface AudioInspectNodeOptions {\n  /** 使用する解析機能名 */\n  featureName: string;\n  /** 解析機能に渡すオプション */\n  featureOptions?: unknown;\n  /** 解析を実行するための内部バッファサイズ（サンプル数） */\n  bufferSize?: number;\n  /** 次の解析を開始するまでのオフセット（サンプル数） */\n  hopSize?: number;\n  /** 入力として期待するチャンネル数 */\n  inputChannelCount?: number;\n  /** 使用するFFTプロバイダー */\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorkletプロセッサーの初期化オプション\n */\nexport interface AudioInspectProcessorOptions {\n  featureName: string;\n  featureOptions?: unknown;\n  bufferSize: number;\n  hopSize: number;\n  inputChannelCount: number;\n  provider?: FFTProviderType;\n}\n\n/**\n * AudioWorklet共通メッセージ型（型安全性向上）\n */\nexport type AudioWorkletMessage =\n  | AnalysisResultMessage\n  | ErrorMessage\n  | UpdateOptionsMessage\n  | ResetMessage;\n\n/**\n * 解析結果メッセージ\n */\nexport interface AnalysisResultMessage {\n  type: 'analysisResult';\n  data: unknown;\n  timestamp: number;\n}\n\n/**\n * Error message\n */\nexport interface ErrorMessage {\n  type: 'error';\n  message: string;\n  detail?: unknown;\n}\n\n/**\n * オプション更新メッセージ\n */\nexport interface UpdateOptionsMessage {\n  type: 'updateOptions';\n  payload: Partial<AudioInspectProcessorOptions>;\n}\n\n/**\n * リセットメッセージ\n */\nexport interface ResetMessage {\n  type: 'reset';\n}\n\n/**\n * AudioInspectNodeのイベントハンドラー\n */\nexport interface AudioInspectNodeEventHandlers {\n  onresult?: (event: { data: unknown; timestamp: number }) => void;\n  onerror?: (event: { message: string; detail?: unknown }) => void;\n}\n\n// Buffer overflow warning message (newly added)\nexport interface BufferOverflowMessage {\n  type: 'bufferOverflow';\n  details: {\n    bufferWritePosition: number;\n    bufferSize: number;\n    timestamp: number;\n  };\n}\n","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<void>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n// WebFFT型定義\ninterface WebFFTInstance {\n  fft(input: Float32Array): Float32Array;\n  profile(): Promise<unknown>;\n  dispose(): void;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: WebFFTInstance | null = null;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {}\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const webfftModule = await import('webfft');\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      const WebFFTConstructor = webfftModule.default as any;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      this.fftInstance = new WebFFTConstructor(this.size) as WebFFTInstance;\n\n      if (this.enableProfiling && this.fftInstance?.profile) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<void> {\n    if (!this.fftInstance || !this.fftInstance.profile) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    await this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance && this.fftInstance.dispose) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * 効率的なネイティブFFTプロバイダー（Cooley-Tukey実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  private bitReversalTable!: Uint32Array;\n  private twiddleFactorsReal!: Float32Array;\n  private twiddleFactorsImag!: Float32Array;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError('INVALID_INPUT', 'FFTサイズは2の冪である必要があります');\n    }\n    this.precomputeTables();\n  }\n\n  get name(): string {\n    return 'Native FFT (Cooley-Tukey)';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  private precomputeTables(): void {\n    // ビット反転テーブルの事前計算\n    this.bitReversalTable = new Uint32Array(this.size);\n    const bits = Math.log2(this.size);\n    for (let i = 0; i < this.size; i++) {\n      let reversed = 0;\n      for (let j = 0; j < bits; j++) {\n        reversed = (reversed << 1) | ((i >> j) & 1);\n      }\n      this.bitReversalTable[i] = reversed;\n    }\n\n    // Twiddle factorsの事前計算\n    const halfSize = this.size / 2;\n    this.twiddleFactorsReal = new Float32Array(halfSize);\n    this.twiddleFactorsImag = new Float32Array(halfSize);\n    for (let i = 0; i < halfSize; i++) {\n      const angle = (-2 * Math.PI * i) / this.size;\n      this.twiddleFactorsReal[i] = Math.cos(angle);\n      this.twiddleFactorsImag[i] = Math.sin(angle);\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // 複素数配列の初期化（ビット反転順）\n    const real = new Float32Array(this.size);\n    const imag = new Float32Array(this.size);\n\n    for (let i = 0; i < this.size; i++) {\n      const reversedIndex = this.bitReversalTable[i];\n      if (reversedIndex !== undefined) {\n        real[reversedIndex] = input[i] || 0;\n        imag[reversedIndex] = 0;\n      }\n    }\n\n    // Cooley-Tukey FFTアルゴリズム\n    for (let stage = 1; stage < this.size; stage *= 2) {\n      const stageSize = stage * 2;\n      const twiddleStep = this.size / stageSize;\n\n      for (let k = 0; k < this.size; k += stageSize) {\n        for (let j = 0; j < stage; j++) {\n          const twiddleIndex = j * twiddleStep;\n          const wr = this.twiddleFactorsReal[twiddleIndex] || 0;\n          const wi = this.twiddleFactorsImag[twiddleIndex] || 0;\n\n          const evenIndex = k + j;\n          const oddIndex = k + j + stage;\n\n          const evenReal = real[evenIndex] || 0;\n          const evenImag = imag[evenIndex] || 0;\n          const oddReal = real[oddIndex] || 0;\n          const oddImag = imag[oddIndex] || 0;\n\n          const tempReal = oddReal * wr - oddImag * wi;\n          const tempImag = oddReal * wi + oddImag * wr;\n\n          real[evenIndex] = evenReal + tempReal;\n          imag[evenIndex] = evenImag + tempImag;\n          real[oddIndex] = evenReal - tempReal;\n          imag[oddIndex] = evenImag - tempImag;\n        }\n      }\n    }\n\n    // 結果の構築\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < this.size; i++) {\n      complex[i * 2] = real[i] || 0;\n      complex[i * 2 + 1] = imag[i] || 0;\n\n      if (i <= this.size / 2) {\n        const realPart = real[i] || 0;\n        const imagPart = imag[i] || 0;\n        magnitude[i] = Math.sqrt(realPart * realPart + imagPart * imagPart);\n        phase[i] = Math.atan2(imagPart, realPart);\n        frequencies[i] = (i * this.sampleRate) / this.size;\n      }\n    }\n\n    return { complex, magnitude, phase, frequencies };\n  }\n\n  dispose(): void {\n    // メモリの明示的な解放（必要に応じて）\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft': {\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider.initializeWebFFT();\n        return provider;\n      }\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default: {\n        const exhaustiveCheck: never = config.type;\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${String(exhaustiveCheck)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { FFTProviderFactory, type FFTProviderType, type FFTResult } from '../core/fft-provider.js';\n\n/**\n * FFT分析のオプション\n */\nexport interface FFTOptions {\n  /** FFTサイズ（デフォルト: 2048、2の累乗である必要があります） */\n  fftSize?: number;\n  /** ウィンドウ関数（デフォルト: 'hann'） */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** オーバーラップ率（デフォルト: 0.5） */\n  overlap?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** FFTプロバイダー（デフォルト: 'webfft'） */\n  provider?: FFTProviderType;\n  /** プロファイリングを有効にする（WebFFTのみ） */\n  enableProfiling?: boolean;\n}\n\n/**\n * スペクトラム解析のオプション\n */\nexport interface SpectrumOptions extends FFTOptions {\n  /** 最小周波数（Hz、デフォルト: 0） */\n  minFrequency?: number;\n  /** 最大周波数（Hz、デフォルト: ナイキスト周波数） */\n  maxFrequency?: number;\n  /** dB表示かどうか（デフォルト: true） */\n  decibels?: boolean;\n  /** 時間フレーム数（スペクトログラム用、デフォルト: 100） */\n  timeFrames?: number;\n}\n\n/**\n * スペクトログラムデータ\n */\nexport interface SpectrogramData {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** 周波数軸（Hz） */\n  frequencies: Float32Array;\n  /** 強度データ（時間 x 周波数） */\n  intensities: Float32Array[];\n  /** フレーム数 */\n  timeFrames: number;\n  /** 周波数ビン数 */\n  frequencyBins: number;\n}\n\n/**\n * FFT分析結果\n */\nexport interface FFTAnalysisResult extends FFTResult {\n  /** FFTサイズ */\n  fftSize: number;\n  /** 使用されたウィンドウ関数 */\n  windowFunction: string;\n  /** プロバイダー名 */\n  providerName: string;\n}\n\n/**\n * スペクトラム解析結果\n */\nexport interface SpectrumAnalysisResult {\n  /** 周波数（Hz） */\n  frequencies: Float32Array;\n  /** 強度 */\n  magnitudes: Float32Array;\n  /** dB値（decielsオプションがtrueの場合） */\n  decibels?: Float32Array;\n  /** スペクトログラム（timeFrames > 1の場合） */\n  spectrogram?: SpectrogramData;\n}\n\n/**\n * ウィンドウ関数を適用\n */\nfunction applyWindow(data: Float32Array, windowType: string): Float32Array {\n  const windowed = new Float32Array(data.length);\n  const N = data.length;\n\n  for (let i = 0; i < N; i++) {\n    let windowValue = 1;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n        break;\n      case 'blackman':\n        windowValue =\n          0.42 -\n          0.5 * Math.cos((2 * Math.PI * i) / (N - 1)) +\n          0.08 * Math.cos((4 * Math.PI * i) / (N - 1));\n        break;\n      case 'none':\n      default:\n        windowValue = 1;\n        break;\n    }\n\n    windowed[i] = (data[i] || 0) * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < -1 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `Invalid channel number: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * FFT分析を行う\n *\n * @param audio - 音声データ\n * @param options - FFTオプション\n * @returns FFT結果\n */\nexport async function getFFT(\n  audio: AudioData,\n  options: FFTOptions = {}\n): Promise<FFTAnalysisResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    provider = 'webfft',\n    enableProfiling = false\n  } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // FFTサイズが入力より大きい場合、ゼロパディング\n  let inputData: Float32Array;\n  if (channelData.length < fftSize) {\n    inputData = new Float32Array(fftSize);\n    inputData.set(channelData);\n  } else {\n    inputData = channelData.slice(0, fftSize);\n  }\n\n  // ウィンドウ関数を適用\n  const windowedData = applyWindow(inputData, windowFunction);\n\n  // FFTプロバイダーを作成\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: provider,\n    fftSize,\n    sampleRate: audio.sampleRate,\n    enableProfiling\n  });\n\n  try {\n    // FFTを実行\n    const result = fftProvider.fft(windowedData);\n\n    return {\n      ...result,\n      fftSize,\n      windowFunction,\n      providerName: fftProvider.name\n    };\n  } finally {\n    // リソースを解放\n    fftProvider.dispose();\n  }\n}\n\n/**\n * スペクトラム解析を行う\n *\n * @param audio - 音声データ\n * @param options - スペクトラムオプション\n * @returns スペクトラム解析結果\n */\nexport async function getSpectrum(\n  audio: AudioData,\n  options: SpectrumOptions = {}\n): Promise<SpectrumAnalysisResult> {\n  const {\n    fftSize = 2048,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    decibels = true,\n    timeFrames = 1,\n    overlap = 0.5,\n    ...fftOptions\n  } = options;\n\n  const channelData = getChannelData(audio, options.channel || 0);\n\n  if (timeFrames === 1) {\n    // 単一フレームのスペクトラム解析\n    const fftResult = await getFFT(audio, { ...fftOptions, fftSize });\n\n    // 周波数範囲をフィルタリング\n    const filteredResult = filterFrequencyRange(fftResult, minFrequency, maxFrequency);\n\n    const result: SpectrumAnalysisResult = {\n      frequencies: filteredResult.frequencies,\n      magnitudes: filteredResult.magnitude\n    };\n\n    if (decibels) {\n      result.decibels = magnitudeToDecibels(filteredResult.magnitude);\n    }\n\n    return result;\n  } else {\n    // スペクトログラム解析\n    const spectrogram = await computeSpectrogram(\n      channelData,\n      audio.sampleRate,\n      fftSize,\n      timeFrames,\n      overlap,\n      { ...fftOptions, minFrequency, maxFrequency, decibels }\n    );\n\n    return {\n      frequencies: spectrogram.frequencies,\n      magnitudes: new Float32Array(), // スペクトログラムでは個別のmagnitudesは空\n      spectrogram\n    };\n  }\n}\n\n/**\n * 周波数範囲をフィルタリング\n */\nfunction filterFrequencyRange(fftResult: FFTResult, minFreq: number, maxFreq: number): FFTResult {\n  const { frequencies, magnitude, phase, complex } = fftResult;\n\n  const startIndex = frequencies.findIndex((f) => f >= minFreq);\n  const endIndex = frequencies.findIndex((f) => f > maxFreq);\n  const actualEndIndex = endIndex === -1 ? frequencies.length : endIndex;\n\n  return {\n    frequencies: frequencies.slice(startIndex, actualEndIndex),\n    magnitude: magnitude.slice(startIndex, actualEndIndex),\n    phase: phase.slice(startIndex, actualEndIndex),\n    complex: complex.slice(startIndex * 2, actualEndIndex * 2)\n  };\n}\n\n/**\n * 振幅をdBに変換\n */\nfunction magnitudeToDecibels(magnitude: Float32Array): Float32Array {\n  const decibels = new Float32Array(magnitude.length);\n  for (let i = 0; i < magnitude.length; i++) {\n    const mag = magnitude[i] || 0;\n    decibels[i] = mag > 0 ? 20 * Math.log10(mag) : -Infinity;\n  }\n  return decibels;\n}\n\n/**\n * スペクトログラム計算のオプション\n */\ninterface SpectrogramOptions {\n  provider?: FFTProviderType;\n  enableProfiling?: boolean;\n  windowFunction?: string;\n  minFrequency?: number;\n  maxFrequency?: number;\n  decibels?: boolean;\n}\n\n/**\n * スペクトログラムを計算\n */\nasync function computeSpectrogram(\n  data: Float32Array,\n  sampleRate: number,\n  fftSize: number,\n  timeFrames: number,\n  overlap: number,\n  options: SpectrogramOptions\n): Promise<SpectrogramData> {\n  const hopSize = Math.floor(fftSize * (1 - overlap));\n\n  // 修正2.2: 短音声データ処理時のフレーム数不足対応\n  let numPossibleFrames;\n  if (data.length === 0) {\n    numPossibleFrames = 0;\n  } else if (data.length < fftSize) {\n    // data.length > 0 かつ data.length < fftSize の場合、1フレームとして処理\n    numPossibleFrames = 1;\n  } else {\n    // data.length >= fftSize の場合\n    numPossibleFrames = Math.floor((data.length - fftSize) / hopSize) + 1;\n  }\n  const actualFrames = Math.min(timeFrames, numPossibleFrames);\n\n  const times = new Float32Array(actualFrames);\n  const intensities: Float32Array[] = [];\n  let frequencies: Float32Array = new Float32Array();\n  let filteredFrequencies: Float32Array = new Float32Array();\n  let frequencyStartIndex = 0;\n  let frequencyEndIndex = 0;\n\n  // FFTプロバイダーを作成（一度だけ）\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: options.provider || 'webfft',\n    fftSize,\n    sampleRate,\n    enableProfiling: options.enableProfiling || false\n  });\n\n  try {\n    for (let frame = 0; frame < actualFrames; frame++) {\n      const startSample = frame * hopSize;\n\n      // フレームデータを抽出\n      const frameData = new Float32Array(fftSize);\n      for (let i = 0; i < fftSize; i++) {\n        frameData[i] = startSample + i < data.length ? data[startSample + i] || 0 : 0;\n      }\n\n      // ウィンドウ関数を適用\n      const windowedData = applyWindow(frameData, options.windowFunction || 'hann');\n\n      // FFTを実行\n      const fftResult = fftProvider.fft(windowedData);\n\n      // 修正2.1: 最初のフレームで周波数範囲フィルタリングを設定\n      if (frame === 0) {\n        frequencies = fftResult.frequencies;\n\n        // 周波数フィルタリングのインデックス範囲を決定\n        const minFreq = options.minFrequency || 0;\n        const maxFreq = options.maxFrequency || sampleRate / 2;\n\n        frequencyStartIndex = frequencies.findIndex((f) => f >= minFreq);\n        if (frequencyStartIndex === -1) frequencyStartIndex = 0;\n\n        const tempEndIndex = frequencies.findIndex((f) => f > maxFreq);\n        frequencyEndIndex = tempEndIndex === -1 ? frequencies.length : tempEndIndex;\n\n        // フィルタリングされた周波数軸を作成\n        filteredFrequencies = frequencies.slice(frequencyStartIndex, frequencyEndIndex);\n      }\n\n      // 強度データを保存（周波数範囲フィルタリング適用）\n      const magnitude = fftResult.magnitude;\n      const filteredMagnitude = magnitude.slice(frequencyStartIndex, frequencyEndIndex);\n      const frameIntensity = options.decibels\n        ? magnitudeToDecibels(filteredMagnitude)\n        : filteredMagnitude;\n      intensities.push(frameIntensity);\n\n      // 時間位置を計算\n      times[frame] = (startSample + fftSize / 2) / sampleRate;\n    }\n  } finally {\n    fftProvider.dispose();\n  }\n\n  return {\n    times,\n    frequencies: filteredFrequencies, // フィルタリングされた周波数軸を返す\n    intensities,\n    timeFrames: actualFrames,\n    frequencyBins: filteredFrequencies.length\n  };\n}\n","import { AudioData, AudioInspectError } from '../types.js';\n\n/**\n * Safely get channel data common function\n * @param audio - AudioData object\n * @param channel - Channel number (-1 for average of all channels)\n * @returns Data of the specified channel\n * @throws AudioInspectError if channel is invalid\n */\nexport function getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // Calculate average of all channels\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (!channelData) {\n          throw new AudioInspectError('INVALID_INPUT', `Channel ${ch} data does not exist`);\n        }\n        if (i < channelData.length) {\n          const sample = channelData[i];\n          if (sample !== undefined) {\n            sum += sample;\n          }\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError(\n      'INVALID_INPUT',\n      `Invalid channel number: ${channel}. Valid range is 0-${audio.numberOfChannels - 1} or -1 (average)`\n    );\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `Channel ${channel} data does not exist`);\n  }\n\n  return channelData;\n}\n\n/**\n * Check if a number is a power of two\n */\nexport function isPowerOfTwo(n: number): boolean {\n  return n > 0 && Number.isInteger(n) && (n & (n - 1)) === 0;\n}\n\n/**\n * Calculate the next power of two\n */\nexport function nextPowerOfTwo(n: number): number {\n  if (!isValidSample(n) || n <= 0) return 1;\n  if (isPowerOfTwo(n)) return n;\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n\n/**\n * Type-safe array access\n */\nexport function safeArrayAccess<T>(array: ArrayLike<T>, index: number, defaultValue: T): T {\n  if (index >= 0 && index < array.length) {\n    return array[index] ?? defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Validate number validity\n */\nexport function isValidSample(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\n/**\n * Safe retrieval of sample values\n */\nexport function ensureValidSample(\n  value: number | undefined | null,\n  defaultValue: number = 0\n): number {\n  return isValidSample(value) ? value : defaultValue;\n}\n\n/**\n * Safe allocation of Float32Array\n */\nexport function ensureFloat32Array(\n  data: Float32Array | undefined | null,\n  length: number\n): Float32Array {\n  if (data instanceof Float32Array && data.length === length) {\n    return data;\n  }\n  return new Float32Array(length);\n}\n\n/**\n * Convert amplitude to dB\n */\nexport function amplitudeToDecibels(amplitude: number, reference: number = 1.0): number {\n  const MIN_AMPLITUDE_FOR_DB = 1e-10; // -200 dBFS\n  const SILENCE_DB = -Infinity;\n\n  if (amplitude <= 0 || reference <= 0) {\n    return SILENCE_DB;\n  }\n\n  const ratio = amplitude / reference;\n  return ratio > MIN_AMPLITUDE_FOR_DB ? 20 * Math.log10(ratio) : SILENCE_DB;\n}\n\n/**\n * Convert dB to amplitude\n */\nexport function decibelsToAmplitude(db: number, reference: number = 1.0): number {\n  if (!isFinite(db)) return 0;\n  return reference * Math.pow(10, db / 20);\n}\n"],"mappings":"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","names":["channelData"]}