{"version":3,"sources":["../src/types.ts","../src/core/load.ts","../src/core/analyze.ts","../src/core/stream.ts","../src/core/fft-provider.ts","../src/features/time.ts","../src/features/frequency.ts"],"sourcesContent":["/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hanning' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioSource, AudioData, LoadOptions, AudioInspectError } from '../types.js';\n\n/**\n * 音声データを読み込み、解析可能な形式に変換する\n */\nexport async function load(source: AudioSource, options: LoadOptions = {}): Promise<AudioData> {\n  try {\n    // 既にAudioDataの場合はそのまま返す\n    if (isAudioData(source)) {\n      return processAudioData(source, options);\n    }\n\n    // Web Audio APIのコンテキストを取得または作成\n    const audioContext = getAudioContext();\n\n    // ソースの種類に応じて処理を分岐\n    const audioBuffer = await decodeAudioSource(source, audioContext);\n\n    // AudioBufferからAudioDataに変換\n    const audioData = audioBufferToAudioData(audioBuffer);\n\n    // オプションに基づいて後処理\n    return processAudioData(audioData, options);\n  } catch (error) {\n    throw new AudioInspectError(\n      'DECODE_ERROR',\n      `音声データの読み込みに失敗しました: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      error\n    );\n  }\n}\n\n/**\n * AudioDataかどうかチェック\n */\nfunction isAudioData(source: AudioSource): source is AudioData {\n  return (\n    typeof source === 'object' &&\n    source !== null &&\n    'sampleRate' in source &&\n    'channelData' in source &&\n    'duration' in source &&\n    'numberOfChannels' in source &&\n    'length' in source\n  );\n}\n\n/**\n * AudioContextを取得または作成\n */\nfunction getAudioContext(): AudioContext {\n  // ブラウザ環境でのみAudioContextを使用\n  if (typeof AudioContext !== 'undefined') {\n    return new AudioContext();\n  }\n  // Node.js環境では別の処理が必要（将来的に実装）\n  throw new AudioInspectError('UNSUPPORTED_FORMAT', 'この環境ではWeb Audio APIが利用できません');\n}\n\n/**\n * ソースの種類に応じてAudioBufferにデコード\n */\nasync function decodeAudioSource(\n  source: AudioSource,\n  audioContext: AudioContext\n): Promise<AudioBuffer> {\n  if (source instanceof AudioBuffer) {\n    return source;\n  }\n\n  if (source instanceof ArrayBuffer) {\n    return await audioContext.decodeAudioData(source);\n  }\n\n  if (source instanceof Blob || source instanceof File) {\n    const arrayBuffer = await source.arrayBuffer();\n    return await audioContext.decodeAudioData(arrayBuffer);\n  }\n\n  if (typeof source === 'string' || source instanceof URL) {\n    const url = source instanceof URL ? source.href : source;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new AudioInspectError(\n        'NETWORK_ERROR',\n        `音声ファイルの取得に失敗しました: ${response.status}`\n      );\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    return await audioContext.decodeAudioData(arrayBuffer);\n  }\n\n  if (source instanceof MediaStream) {\n    // MediaStreamの処理は複雑なので、将来的に実装\n    throw new AudioInspectError(\n      'UNSUPPORTED_FORMAT',\n      'MediaStreamの処理は現在サポートされていません'\n    );\n  }\n\n  throw new AudioInspectError('INVALID_INPUT', 'サポートされていない音声ソースです');\n}\n\n/**\n * AudioBufferからAudioDataに変換\n */\nfunction audioBufferToAudioData(buffer: AudioBuffer): AudioData {\n  const channelData: Float32Array[] = [];\n\n  for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n    channelData.push(buffer.getChannelData(channel));\n  }\n\n  return {\n    sampleRate: buffer.sampleRate,\n    channelData,\n    duration: buffer.duration,\n    numberOfChannels: buffer.numberOfChannels,\n    length: buffer.length\n  };\n}\n\n/**\n * オプションに基づいてAudioDataを後処理\n */\nfunction processAudioData(audioData: AudioData, options: LoadOptions): AudioData {\n  let result = audioData;\n\n  // モノラル変換\n  if (options.channels === 'mono' || options.channels === 1) {\n    result = convertToMono(result);\n  }\n\n  // 正規化\n  if (options.normalize) {\n    result = normalize(result);\n  }\n\n  // サンプルレート変換（簡易実装）\n  if (options.sampleRate && options.sampleRate !== result.sampleRate) {\n    // 本格的なリサンプリングは複雑なので、警告のみ\n    console.warn('サンプルレート変換は現在サポートされていません');\n  }\n\n  return result;\n}\n\n/**\n * モノラルに変換\n */\nfunction convertToMono(audioData: AudioData): AudioData {\n  if (audioData.numberOfChannels === 1) {\n    return audioData;\n  }\n\n  const monoData = new Float32Array(audioData.length);\n\n  // 全チャンネルの平均を取る\n  for (let i = 0; i < audioData.length; i++) {\n    let sum = 0;\n    for (let channel = 0; channel < audioData.numberOfChannels; channel++) {\n      sum += audioData.channelData[channel]![i]!;\n    }\n    monoData[i] = sum / audioData.numberOfChannels;\n  }\n\n  return {\n    sampleRate: audioData.sampleRate,\n    channelData: [monoData],\n    duration: audioData.duration,\n    numberOfChannels: 1,\n    length: audioData.length\n  };\n}\n\n/**\n * 正規化（最大値を1.0にする）\n */\nfunction normalize(audioData: AudioData): AudioData {\n  // 最大振幅を見つける\n  let maxAmplitude = 0;\n  for (const channelData of audioData.channelData) {\n    for (const sample of channelData) {\n      maxAmplitude = Math.max(maxAmplitude, Math.abs(sample));\n    }\n  }\n\n  if (maxAmplitude === 0) {\n    return audioData; // 無音の場合はそのまま\n  }\n\n  // 正規化\n  const normalizedChannels = audioData.channelData.map((channelData) => {\n    const normalized = new Float32Array(channelData.length);\n    for (let i = 0; i < channelData.length; i++) {\n      normalized[i] = channelData[i]! / maxAmplitude;\n    }\n    return normalized;\n  });\n\n  return {\n    ...audioData,\n    channelData: normalizedChannels\n  };\n}\n","import { AudioData, Feature, AudioInspectError } from '../types.js';\n\n/**\n * 音声データから特徴量を抽出する\n */\nexport async function analyze<T>(audio: AudioData, feature: Feature<T>): Promise<T> {\n  try {\n    // 入力検証\n    validateAudioData(audio);\n\n    // 特徴抽出関数を実行\n    const result = await feature(audio);\n\n    return result;\n  } catch (error) {\n    // すでにAudioInspectErrorの場合はそのまま再投げ\n    if (error instanceof AudioInspectError) {\n      throw error;\n    }\n\n    // その他のエラーをラップ\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    throw new AudioInspectError(\n      'PROCESSING_ERROR',\n      `特徴量の抽出に失敗しました: ${message}`,\n      error\n    );\n  }\n}\n\n/**\n * AudioDataの入力検証\n */\nfunction validateAudioData(audio: AudioData): void {\n  if (!audio || typeof audio !== 'object') {\n    throw new AudioInspectError('INVALID_INPUT', 'AudioDataが無効です');\n  }\n\n  if (typeof audio.sampleRate !== 'number' || audio.sampleRate <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'サンプルレートが無効です');\n  }\n\n  if (!Array.isArray(audio.channelData) || audio.channelData.length === 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'チャンネルデータが無効です');\n  }\n\n  if (\n    typeof audio.numberOfChannels !== 'number' ||\n    audio.numberOfChannels !== audio.channelData.length\n  ) {\n    throw new AudioInspectError('INVALID_INPUT', 'チャンネル数が一致しません');\n  }\n\n  if (typeof audio.length !== 'number' || audio.length <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', 'データ長が無効です');\n  }\n\n  if (typeof audio.duration !== 'number' || audio.duration <= 0) {\n    throw new AudioInspectError('INVALID_INPUT', '音声の長さが無効です');\n  }\n\n  // 各チャンネルのデータ長が一致することを確認\n  const expectedLength = audio.channelData[0]!.length;\n  for (let i = 0; i < audio.channelData.length; i++) {\n    const channelData = audio.channelData[i];\n    if (!(channelData instanceof Float32Array)) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `チャンネル ${i} のデータが Float32Array ではありません`\n      );\n    }\n    if (channelData.length !== expectedLength) {\n      throw new AudioInspectError('INVALID_INPUT', `チャンネル ${i} のデータ長が一致しません`);\n    }\n  }\n}\n","import { AudioSource, Feature, StreamController, StreamOptions, AudioInspectError } from '../types.js';\n\nexport function stream<T>(\n  _source: AudioSource,\n  _feature: Feature<T>,\n  _options?: StreamOptions\n): StreamController {\n  // TODO: ストリーミング機能の実装\n  throw new AudioInspectError(\n    'UNSUPPORTED_FORMAT',\n    'stream機能は現在実装中です。次のバージョンで利用可能になります。'\n  );\n}\n","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<any>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: any;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {\n    this.initializeWebFFT();\n  }\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  private async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const WebFFT = (await import('webfft')).default;\n      this.fftInstance = new WebFFT(this.size);\n\n      if (this.enableProfiling) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<any> {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    return this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * ネイティブFFTプロバイダー（シンプルなDFT実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError('INVALID_INPUT', 'FFTサイズは2の累乗である必要があります');\n    }\n  }\n\n  get name(): string {\n    return 'Native DFT';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // シンプルなDFT実装（教育目的、パフォーマンスは低い）\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let k = 0; k < this.size; k++) {\n      let realSum = 0;\n      let imagSum = 0;\n\n      for (let n = 0; n < this.size; n++) {\n        const angle = (-2 * Math.PI * k * n) / this.size;\n        realSum += input[n]! * Math.cos(angle);\n        imagSum += input[n]! * Math.sin(angle);\n      }\n\n      complex[k * 2] = realSum;\n      complex[k * 2 + 1] = imagSum;\n\n      // 正の周波数のみ保存\n      if (k <= this.size / 2) {\n        magnitude[k] = Math.sqrt(realSum * realSum + imagSum * imagSum);\n        phase[k] = Math.atan2(imagSum, realSum);\n        frequencies[k] = (k * this.sampleRate) / this.size;\n      }\n    }\n\n    return {\n      complex,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  dispose(): void {\n    // ネイティブ実装では特に何もしない\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft':\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider['initializeWebFFT']();\n        return provider;\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default:\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${config.type}`\n        );\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n","import { AudioData } from '../types.js';\n\n/**\n * ピーク検出のオプション\n */\nexport interface PeaksOptions {\n  /** 抽出するピークの数（デフォルト: 100） */\n  count?: number;\n  /** ピーク検出の閾値（0-1、デフォルト: 0.1） */\n  threshold?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 最小ピーク間距離（サンプル数、デフォルト: サンプルレート/100） */\n  minDistance?: number;\n}\n\n/**\n * ピーク情報\n */\nexport interface Peak {\n  /** ピークの位置（サンプル数） */\n  position: number;\n  /** ピークの時間位置（秒） */\n  time: number;\n  /** ピークの振幅（0-1） */\n  amplitude: number;\n}\n\n/**\n * ピーク検出結果\n */\nexport interface PeaksResult {\n  /** 検出されたピーク */\n  peaks: Peak[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n}\n\n/**\n * ピーク検出を行う\n */\nexport function getPeaks(audio: AudioData, options: PeaksOptions = {}): PeaksResult {\n  const {\n    count = 100,\n    threshold = 0.1,\n    channel = 0,\n    minDistance = Math.floor(audio.sampleRate / 100)\n  } = options;\n\n  // 解析対象のチャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // ピーク候補を検出\n  const peakCandidates = findPeakCandidates(channelData, threshold, minDistance);\n\n  // 振幅でソートして上位を選択\n  const sortedPeaks = peakCandidates.sort((a, b) => b.amplitude - a.amplitude).slice(0, count);\n\n  // 時間順にソート\n  sortedPeaks.sort((a, b) => a.position - b.position);\n\n  // 統計情報を計算\n  const maxAmplitude =\n    peakCandidates.length > 0 ? Math.max(...peakCandidates.map((p) => p.amplitude)) : 0;\n\n  const averageAmplitude =\n    peakCandidates.length > 0\n      ? peakCandidates.reduce((sum, p) => sum + p.amplitude, 0) / peakCandidates.length\n      : 0;\n\n  return {\n    peaks: sortedPeaks.map((candidate) => ({\n      position: candidate.position,\n      time: candidate.position / audio.sampleRate,\n      amplitude: candidate.amplitude\n    })),\n    maxAmplitude,\n    averageAmplitude\n  };\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new Error(`無効なチャンネル番号: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new Error(`チャンネル ${channel} のデータが存在しません`);\n  }\n\n  return channelData;\n}\n\n/**\n * ピーク候補を検出\n */\nfunction findPeakCandidates(data: Float32Array, threshold: number, minDistance: number): Peak[] {\n  const peaks: Peak[] = [];\n  const length = data.length;\n\n  for (let i = 1; i < length - 1; i++) {\n    // 境界チェック済みなので安全にアクセス\n    const current = Math.abs(data[i] as number);\n    const prev = Math.abs(data[i - 1] as number);\n    const next = Math.abs(data[i + 1] as number);\n\n    // ローカルマキシマかつ閾値を超えているかチェック\n    if (current > prev && current > next && current > threshold) {\n      // 既存のピークとの最小距離をチェック\n      let shouldAdd = true;\n      let replaceIndex = -1;\n\n      for (let j = 0; j < peaks.length; j++) {\n        const peak = peaks[j] as Peak; // 配列内の要素なので存在保証\n        const distance = Math.abs(peak.position - i);\n        if (distance < minDistance) {\n          // 既存のピークと近すぎる\n          if (current > peak.amplitude) {\n            // より大きい振幅なので既存ピークを置き換え\n            replaceIndex = j;\n          }\n          shouldAdd = false;\n          break;\n        }\n      }\n\n      if (replaceIndex >= 0) {\n        // 既存ピークを置き換え\n        peaks[replaceIndex] = {\n          position: i,\n          time: 0,\n          amplitude: current\n        };\n      } else if (shouldAdd) {\n        // 新しいピークを追加\n        peaks.push({\n          position: i,\n          time: 0,\n          amplitude: current\n        });\n      }\n    }\n  }\n\n  return peaks;\n}\n\n/**\n * RMS（Root Mean Square）を計算\n */\nexport function getRMS(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  let sum = 0;\n  for (let i = 0; i < channelData.length; i++) {\n    const sample = channelData[i] as number;\n    sum += sample * sample;\n  }\n\n  return Math.sqrt(sum / channelData.length);\n}\n\n/**\n * ゼロクロッシング率を計算\n */\nexport function getZeroCrossing(audio: AudioData, channel = 0): number {\n  const channelData = getChannelData(audio, channel);\n\n  let crossings = 0;\n  for (let i = 1; i < channelData.length; i++) {\n    const prev = channelData[i - 1] as number;\n    const current = channelData[i] as number;\n\n    // 符号が変わった場合はゼロクロッシング\n    if ((prev >= 0 && current < 0) || (prev < 0 && current >= 0)) {\n      crossings++;\n    }\n  }\n\n  return crossings / (channelData.length - 1);\n}\n\n/**\n * 波形データ取得のオプション\n */\nexport interface WaveformOptions {\n  /** 1秒あたりのサンプル数（解像度、デフォルト: 60） */\n  framesPerSecond?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** 振幅の計算方法（デフォルト: 'rms'） */\n  method?: 'rms' | 'peak' | 'average';\n}\n\n/**\n * 波形データポイント\n */\nexport interface WaveformPoint {\n  /** 時間位置（秒） */\n  time: number;\n  /** 振幅値（0-1） */\n  amplitude: number;\n}\n\n/**\n * 波形データ取得結果\n */\nexport interface WaveformResult {\n  /** 波形データポイントの配列 */\n  waveform: WaveformPoint[];\n  /** 最大振幅 */\n  maxAmplitude: number;\n  /** 平均振幅 */\n  averageAmplitude: number;\n  /** フレーム数 */\n  frameCount: number;\n  /** フレームあたりのサンプル数 */\n  samplesPerFrame: number;\n}\n\n/**\n * 時間軸に沿った波形データを取得\n *\n * @param audio - 音声データ\n * @param options - 波形データ取得オプション\n * @returns 波形データ\n */\nexport function getWaveform(audio: AudioData, options: WaveformOptions = {}): WaveformResult {\n  const { framesPerSecond = 60, channel = 0, method = 'rms' } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // フレーム計算\n  const frameCount = Math.ceil(audio.duration * framesPerSecond);\n  const samplesPerFrame = Math.floor(audio.length / frameCount);\n\n  const waveform: WaveformPoint[] = [];\n  let maxAmplitude = 0;\n  let totalAmplitude = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const startSample = i * samplesPerFrame;\n    const endSample = Math.min(startSample + samplesPerFrame, channelData.length);\n\n    // フレーム内のデータを抽出\n    const frameData = channelData.slice(startSample, endSample);\n\n    // 指定された方法で振幅を計算\n    let amplitude: number;\n    switch (method) {\n      case 'peak':\n        amplitude = calculatePeakAmplitude(frameData);\n        break;\n      case 'average':\n        amplitude = calculateAverageAmplitude(frameData);\n        break;\n      case 'rms':\n      default:\n        amplitude = calculateRMSAmplitude(frameData);\n        break;\n    }\n\n    const time = (startSample + (endSample - startSample) / 2) / audio.sampleRate;\n\n    waveform.push({ time, amplitude });\n    maxAmplitude = Math.max(maxAmplitude, amplitude);\n    totalAmplitude += amplitude;\n  }\n\n  const averageAmplitude = frameCount > 0 ? totalAmplitude / frameCount : 0;\n\n  return {\n    waveform,\n    maxAmplitude,\n    averageAmplitude,\n    frameCount,\n    samplesPerFrame\n  };\n}\n\n/**\n * フレーム内のRMS振幅を計算\n */\nfunction calculateRMSAmplitude(frameData: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = frameData[i] as number;\n    sum += sample * sample;\n  }\n  return Math.sqrt(sum / frameData.length);\n}\n\n/**\n * フレーム内のピーク振幅を計算\n */\nfunction calculatePeakAmplitude(frameData: Float32Array): number {\n  let peak = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    const sample = Math.abs(frameData[i] as number);\n    peak = Math.max(peak, sample);\n  }\n  return peak;\n}\n\n/**\n * フレーム内の平均振幅を計算\n */\nfunction calculateAverageAmplitude(frameData: Float32Array): number {\n  let sum = 0;\n  for (let i = 0; i < frameData.length; i++) {\n    sum += Math.abs(frameData[i] as number);\n  }\n  return frameData.length > 0 ? sum / frameData.length : 0;\n}\n","import { AudioData, AudioInspectError } from '../types.js';\nimport { FFTProviderFactory, type FFTProviderType, type FFTResult } from '../core/fft-provider.js';\n\n/**\n * FFT分析のオプション\n */\nexport interface FFTOptions {\n  /** FFTサイズ（デフォルト: 2048、2の累乗である必要があります） */\n  fftSize?: number;\n  /** ウィンドウ関数（デフォルト: 'hann'） */\n  windowFunction?: 'hann' | 'hamming' | 'blackman' | 'none';\n  /** オーバーラップ率（デフォルト: 0.5） */\n  overlap?: number;\n  /** 解析するチャンネル（デフォルト: 0、-1で全チャンネルの平均） */\n  channel?: number;\n  /** FFTプロバイダー（デフォルト: 'webfft'） */\n  provider?: FFTProviderType;\n  /** プロファイリングを有効にする（WebFFTのみ） */\n  enableProfiling?: boolean;\n}\n\n/**\n * スペクトラム解析のオプション\n */\nexport interface SpectrumOptions extends FFTOptions {\n  /** 最小周波数（Hz、デフォルト: 0） */\n  minFrequency?: number;\n  /** 最大周波数（Hz、デフォルト: ナイキスト周波数） */\n  maxFrequency?: number;\n  /** dB表示かどうか（デフォルト: true） */\n  decibels?: boolean;\n  /** 時間フレーム数（スペクトログラム用、デフォルト: 100） */\n  timeFrames?: number;\n}\n\n/**\n * スペクトログラムデータ\n */\nexport interface SpectrogramData {\n  /** 時間軸（秒） */\n  times: Float32Array;\n  /** 周波数軸（Hz） */\n  frequencies: Float32Array;\n  /** 強度データ（時間 x 周波数） */\n  intensities: Float32Array[];\n  /** フレーム数 */\n  timeFrames: number;\n  /** 周波数ビン数 */\n  frequencyBins: number;\n}\n\n/**\n * FFT分析結果\n */\nexport interface FFTAnalysisResult extends FFTResult {\n  /** FFTサイズ */\n  fftSize: number;\n  /** 使用されたウィンドウ関数 */\n  windowFunction: string;\n  /** プロバイダー名 */\n  providerName: string;\n}\n\n/**\n * スペクトラム解析結果\n */\nexport interface SpectrumAnalysisResult {\n  /** 周波数（Hz） */\n  frequencies: Float32Array;\n  /** 強度 */\n  magnitudes: Float32Array;\n  /** dB値（decielsオプションがtrueの場合） */\n  decibels?: Float32Array;\n  /** スペクトログラム（timeFrames > 1の場合） */\n  spectrogram?: SpectrogramData;\n}\n\n/**\n * ウィンドウ関数を適用\n */\nfunction applyWindow(data: Float32Array, windowType: string): Float32Array {\n  const windowed = new Float32Array(data.length);\n  const N = data.length;\n\n  for (let i = 0; i < N; i++) {\n    let windowValue = 1;\n\n    switch (windowType) {\n      case 'hann':\n        windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\n        break;\n      case 'hamming':\n        windowValue = 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (N - 1));\n        break;\n      case 'blackman':\n        windowValue =\n          0.42 -\n          0.5 * Math.cos((2 * Math.PI * i) / (N - 1)) +\n          0.08 * Math.cos((4 * Math.PI * i) / (N - 1));\n        break;\n      case 'none':\n      default:\n        windowValue = 1;\n        break;\n    }\n\n    windowed[i] = (data[i] || 0) * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * 指定されたチャンネルのデータを取得\n */\nfunction getChannelData(audio: AudioData, channel: number): Float32Array {\n  if (channel === -1) {\n    // 全チャンネルの平均を計算\n    const averageData = new Float32Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      let sum = 0;\n      for (let ch = 0; ch < audio.numberOfChannels; ch++) {\n        const channelData = audio.channelData[ch];\n        if (channelData && i < channelData.length) {\n          sum += channelData[i] as number;\n        }\n      }\n      averageData[i] = sum / audio.numberOfChannels;\n    }\n    return averageData;\n  }\n\n  if (channel < 0 || channel >= audio.numberOfChannels) {\n    throw new AudioInspectError('INVALID_INPUT', `無効なチャンネル番号: ${channel}`);\n  }\n\n  const channelData = audio.channelData[channel];\n  if (!channelData) {\n    throw new AudioInspectError('INVALID_INPUT', `チャンネル ${channel} のデータが存在しません`);\n  }\n\n  return channelData;\n}\n\n/**\n * FFT分析を行う\n *\n * @param audio - 音声データ\n * @param options - FFTオプション\n * @returns FFT結果\n */\nexport async function getFFT(\n  audio: AudioData,\n  options: FFTOptions = {}\n): Promise<FFTAnalysisResult> {\n  const {\n    fftSize = 2048,\n    windowFunction = 'hann',\n    channel = 0,\n    provider = 'webfft',\n    enableProfiling = false\n  } = options;\n\n  // チャンネルデータを取得\n  const channelData = getChannelData(audio, channel);\n\n  // FFTサイズが入力より大きい場合、ゼロパディング\n  let inputData: Float32Array;\n  if (channelData.length < fftSize) {\n    inputData = new Float32Array(fftSize);\n    inputData.set(channelData);\n  } else {\n    inputData = channelData.slice(0, fftSize);\n  }\n\n  // ウィンドウ関数を適用\n  const windowedData = applyWindow(inputData, windowFunction);\n\n  // FFTプロバイダーを作成\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: provider,\n    fftSize,\n    sampleRate: audio.sampleRate,\n    enableProfiling\n  });\n\n  try {\n    // FFTを実行\n    const result = fftProvider.fft(windowedData);\n\n    return {\n      ...result,\n      fftSize,\n      windowFunction,\n      providerName: fftProvider.name\n    };\n  } finally {\n    // リソースを解放\n    fftProvider.dispose();\n  }\n}\n\n/**\n * スペクトラム解析を行う\n *\n * @param audio - 音声データ\n * @param options - スペクトラムオプション\n * @returns スペクトラム解析結果\n */\nexport async function getSpectrum(\n  audio: AudioData,\n  options: SpectrumOptions = {}\n): Promise<SpectrumAnalysisResult> {\n  const {\n    fftSize = 2048,\n    minFrequency = 0,\n    maxFrequency = audio.sampleRate / 2,\n    decibels = true,\n    timeFrames = 1,\n    overlap = 0.5,\n    ...fftOptions\n  } = options;\n\n  const channelData = getChannelData(audio, options.channel || 0);\n\n  if (timeFrames === 1) {\n    // 単一フレームのスペクトラム解析\n    const fftResult = await getFFT(audio, { ...fftOptions, fftSize });\n\n    // 周波数範囲をフィルタリング\n    const filteredResult = filterFrequencyRange(fftResult, minFrequency, maxFrequency);\n\n    const result: SpectrumAnalysisResult = {\n      frequencies: filteredResult.frequencies,\n      magnitudes: filteredResult.magnitude\n    };\n\n    if (decibels) {\n      result.decibels = magnitudeToDecibels(filteredResult.magnitude);\n    }\n\n    return result;\n  } else {\n    // スペクトログラム解析\n    const spectrogram = await computeSpectrogram(\n      channelData,\n      audio.sampleRate,\n      fftSize,\n      timeFrames,\n      overlap,\n      { ...fftOptions, minFrequency, maxFrequency, decibels }\n    );\n\n    return {\n      frequencies: spectrogram.frequencies,\n      magnitudes: new Float32Array(), // スペクトログラムでは個別のmagnitudesは空\n      spectrogram\n    };\n  }\n}\n\n/**\n * 周波数範囲をフィルタリング\n */\nfunction filterFrequencyRange(fftResult: FFTResult, minFreq: number, maxFreq: number): FFTResult {\n  const { frequencies, magnitude, phase, complex } = fftResult;\n\n  const startIndex = frequencies.findIndex((f) => f >= minFreq);\n  const endIndex = frequencies.findIndex((f) => f > maxFreq);\n  const actualEndIndex = endIndex === -1 ? frequencies.length : endIndex;\n\n  return {\n    frequencies: frequencies.slice(startIndex, actualEndIndex),\n    magnitude: magnitude.slice(startIndex, actualEndIndex),\n    phase: phase.slice(startIndex, actualEndIndex),\n    complex: complex.slice(startIndex * 2, actualEndIndex * 2)\n  };\n}\n\n/**\n * 振幅をdBに変換\n */\nfunction magnitudeToDecibels(magnitude: Float32Array): Float32Array {\n  const decibels = new Float32Array(magnitude.length);\n  for (let i = 0; i < magnitude.length; i++) {\n    const mag = magnitude[i] || 0;\n    decibels[i] = mag > 0 ? 20 * Math.log10(mag) : -Infinity;\n  }\n  return decibels;\n}\n\n/**\n * スペクトログラムを計算\n */\nasync function computeSpectrogram(\n  data: Float32Array,\n  sampleRate: number,\n  fftSize: number,\n  timeFrames: number,\n  overlap: number,\n  options: any\n): Promise<SpectrogramData> {\n  const hopSize = Math.floor(fftSize * (1 - overlap));\n  const actualFrames = Math.min(timeFrames, Math.floor((data.length - fftSize) / hopSize) + 1);\n\n  const times = new Float32Array(actualFrames);\n  const intensities: Float32Array[] = [];\n  let frequencies: Float32Array = new Float32Array();\n\n  // FFTプロバイダーを作成（一度だけ）\n  const fftProvider = await FFTProviderFactory.createProvider({\n    type: options.provider || 'webfft',\n    fftSize,\n    sampleRate,\n    enableProfiling: options.enableProfiling || false\n  });\n\n  try {\n    for (let frame = 0; frame < actualFrames; frame++) {\n      const startSample = frame * hopSize;\n\n      // フレームデータを抽出\n      const frameData = new Float32Array(fftSize);\n      for (let i = 0; i < fftSize && startSample + i < data.length; i++) {\n        frameData[i] = data[startSample + i] || 0;\n      }\n\n      // ウィンドウ関数を適用\n      const windowedData = applyWindow(frameData, options.windowFunction || 'hann');\n\n      // FFTを実行\n      const fftResult = fftProvider.fft(windowedData);\n\n      // 最初のフレームで周波数軸を設定\n      if (frame === 0) {\n        frequencies = fftResult.frequencies;\n      }\n\n      // 強度データを保存\n      const magnitude = fftResult.magnitude;\n      const frameIntensity = options.decibels ? magnitudeToDecibels(magnitude) : magnitude;\n      intensities.push(frameIntensity);\n\n      // 時間位置を計算\n      times[frame] = (startSample + fftSize / 2) / sampleRate;\n    }\n  } finally {\n    fftProvider.dispose();\n  }\n\n  return {\n    times,\n    frequencies,\n    intensities,\n    timeFrames: actualFrames,\n    frequencyBins: frequencies.length\n  };\n}\n"],"mappings":"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","names":["channelData","getChannelData","channelData"]}