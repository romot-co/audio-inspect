{"version":3,"sources":["../../src/types.ts","../../src/core/fft-provider.ts"],"sourcesContent":["/**\n * 音声ソースの型定義\n */\nexport type AudioSource = \n  | ArrayBuffer \n  | Blob \n  | File\n  | URL \n  | string // URLパス\n  | MediaStream \n  | AudioBuffer\n  | AudioData;\n\n/**\n * 音声データの構造\n */\nexport interface AudioData {\n  /** サンプルレート（Hz） */\n  sampleRate: number;\n  /** チャンネルごとのオーディオデータ */\n  channelData: Float32Array[];\n  /** 音声の長さ（秒） */\n  duration: number;\n  /** チャンネル数 */\n  numberOfChannels: number;\n  /** サンプル数 */\n  length: number;\n}\n\n/**\n * 特徴抽出関数の型\n */\nexport type Feature<T> = (audio: AudioData, options?: any) => T | Promise<T>;\n\n/**\n * ロード時のオプション\n */\nexport interface LoadOptions {\n  /** リサンプリング対象のサンプルレート */\n  sampleRate?: number;\n  /** チャンネル数の指定 */\n  channels?: number | 'mono';\n  /** 正規化するか */\n  normalize?: boolean;\n  /** 遅延読み込み（大きなファイル用） */\n  lazy?: boolean;\n  /** チャンクサイズ（ストリーミング時） */\n  chunkSize?: number;\n}\n\n/**\n * ストリーミング制御インターフェース\n */\nexport interface StreamController {\n  pause(): void;\n  resume(): void;\n  stop(): void;\n  readonly paused: boolean;\n}\n\n/**\n * ストリーミングオプション\n */\nexport interface StreamOptions {\n  /** バッファサイズ */\n  bufferSize?: number;\n  /** ホップサイズ */\n  hopSize?: number;\n  /** 更新頻度の制限（ミリ秒） */\n  throttle?: number;\n  /** 窓関数の種類 */\n  windowFunction?: WindowFunction;\n}\n\n/**\n * 窓関数の種類\n */\nexport type WindowFunction = 'hanning' | 'hamming' | 'blackman' | 'rectangular';\n\n/**\n * エラーコード\n */\nexport type ErrorCode = \n  | 'INVALID_INPUT'\n  | 'UNSUPPORTED_FORMAT' \n  | 'DECODE_ERROR'\n  | 'NETWORK_ERROR'\n  | 'FFT_PROVIDER_ERROR'\n  | 'PROCESSING_ERROR';\n\n/**\n * audio-inspect固有のエラー\n */\nexport class AudioInspectError extends Error {\n  public override readonly name = 'AudioInspectError';\n\n  constructor(\n    public readonly code: ErrorCode,\n    message: string,\n    public override readonly cause?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * audio-inspect固有のエラーかチェック\n */\nexport function isAudioInspectError(error: unknown): error is AudioInspectError {\n  return error instanceof AudioInspectError;\n} ","import { AudioInspectError } from '../types.js';\n\n/**\n * FFTプロバイダーの種類\n */\nexport type FFTProviderType = 'webfft' | 'native' | 'custom';\n\n/**\n * FFT結果\n */\nexport interface FFTResult {\n  /** 複素数結果（インターリーブ形式：実部、虚部、実部、虚部...） */\n  complex: Float32Array;\n  /** 振幅スペクトラム */\n  magnitude: Float32Array;\n  /** 位相スペクトラム */\n  phase: Float32Array;\n  /** 周波数ビン（Hz） */\n  frequencies: Float32Array;\n}\n\n/**\n * FFTプロバイダーのインターフェース\n */\nexport interface IFFTProvider {\n  /** プロバイダー名 */\n  readonly name: string;\n  /** FFTサイズ */\n  readonly size: number;\n  /** サンプルレート */\n  readonly sampleRate: number;\n\n  /**\n   * FFTを実行\n   * @param input - 実数入力データ\n   * @returns FFT結果\n   */\n  fft(input: Float32Array): FFTResult;\n\n  /**\n   * リソースを解放\n   */\n  dispose(): void;\n\n  /**\n   * プロファイリングを実行（対応している場合）\n   */\n  profile?(): Promise<any>;\n}\n\n/**\n * FFTプロバイダーの設定\n */\nexport interface FFTProviderConfig {\n  /** プロバイダータイプ */\n  type: FFTProviderType;\n  /** FFTサイズ（2の累乗である必要があります） */\n  fftSize: number;\n  /** サンプルレート */\n  sampleRate: number;\n  /** 自動プロファイリングを有効にするか */\n  enableProfiling?: boolean;\n  /** カスタムプロバイダー（type='custom'の場合） */\n  customProvider?: IFFTProvider;\n}\n\n/**\n * WebFFTプロバイダーの実装\n */\nclass WebFFTProvider implements IFFTProvider {\n  private fftInstance: any;\n\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number,\n    private enableProfiling: boolean = false\n  ) {\n    this.initializeWebFFT();\n  }\n\n  get name(): string {\n    return 'WebFFT';\n  }\n\n  private async initializeWebFFT(): Promise<void> {\n    try {\n      // Dynamic import to handle module loading\n      const WebFFT = (await import('webfft')).default;\n      this.fftInstance = new WebFFT(this.size);\n\n      if (this.enableProfiling) {\n        await this.fftInstance.profile();\n      }\n    } catch (error) {\n      throw new AudioInspectError(\n        'UNSUPPORTED_FORMAT',\n        `WebFFTの初期化に失敗しました: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // WebFFTは複素数入力（インターリーブ形式）を期待するので、実数を複素数に変換\n    const complexInput = new Float32Array(this.size * 2);\n    for (let i = 0; i < this.size; i++) {\n      complexInput[i * 2] = input[i] || 0; // 実部\n      complexInput[i * 2 + 1] = 0; // 虚部（0で初期化）\n    }\n\n    // FFT実行\n    const complexOutput = this.fftInstance.fft(complexInput);\n\n    // 結果を処理\n    const magnitude = new Float32Array(this.size / 2 + 1); // 正の周波数のみ\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let i = 0; i < magnitude.length; i++) {\n      const real = complexOutput[i * 2] || 0;\n      const imag = complexOutput[i * 2 + 1] || 0;\n\n      magnitude[i] = Math.sqrt(real * real + imag * imag);\n      phase[i] = Math.atan2(imag, real);\n      frequencies[i] = (i * this.sampleRate) / this.size;\n    }\n\n    return {\n      complex: complexOutput,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  async profile(): Promise<any> {\n    if (!this.fftInstance) {\n      throw new AudioInspectError('UNSUPPORTED_FORMAT', 'WebFFTが初期化されていません');\n    }\n\n    return this.fftInstance.profile();\n  }\n\n  dispose(): void {\n    if (this.fftInstance) {\n      this.fftInstance.dispose();\n      this.fftInstance = null;\n    }\n  }\n}\n\n/**\n * ネイティブFFTプロバイダー（シンプルなDFT実装）\n */\nclass NativeFFTProvider implements IFFTProvider {\n  constructor(\n    public readonly size: number,\n    public readonly sampleRate: number\n  ) {\n    if (!this.isPowerOfTwo(size)) {\n      throw new AudioInspectError('INVALID_INPUT', 'FFTサイズは2の累乗である必要があります');\n    }\n  }\n\n  get name(): string {\n    return 'Native DFT';\n  }\n\n  private isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n  }\n\n  fft(input: Float32Array): FFTResult {\n    if (input.length !== this.size) {\n      throw new AudioInspectError(\n        'INVALID_INPUT',\n        `入力サイズが不正です。期待値: ${this.size}, 実際: ${input.length}`\n      );\n    }\n\n    // シンプルなDFT実装（教育目的、パフォーマンスは低い）\n    const complex = new Float32Array(this.size * 2);\n    const magnitude = new Float32Array(this.size / 2 + 1);\n    const phase = new Float32Array(this.size / 2 + 1);\n    const frequencies = new Float32Array(this.size / 2 + 1);\n\n    for (let k = 0; k < this.size; k++) {\n      let realSum = 0;\n      let imagSum = 0;\n\n      for (let n = 0; n < this.size; n++) {\n        const angle = (-2 * Math.PI * k * n) / this.size;\n        realSum += input[n]! * Math.cos(angle);\n        imagSum += input[n]! * Math.sin(angle);\n      }\n\n      complex[k * 2] = realSum;\n      complex[k * 2 + 1] = imagSum;\n\n      // 正の周波数のみ保存\n      if (k <= this.size / 2) {\n        magnitude[k] = Math.sqrt(realSum * realSum + imagSum * imagSum);\n        phase[k] = Math.atan2(imagSum, realSum);\n        frequencies[k] = (k * this.sampleRate) / this.size;\n      }\n    }\n\n    return {\n      complex,\n      magnitude,\n      phase,\n      frequencies\n    };\n  }\n\n  dispose(): void {\n    // ネイティブ実装では特に何もしない\n  }\n}\n\n/**\n * FFTプロバイダーファクトリー\n */\nexport class FFTProviderFactory {\n  /**\n   * 指定された設定でFFTプロバイダーを作成\n   */\n  static async createProvider(config: FFTProviderConfig): Promise<IFFTProvider> {\n    switch (config.type) {\n      case 'webfft':\n        const provider = new WebFFTProvider(\n          config.fftSize,\n          config.sampleRate,\n          config.enableProfiling\n        );\n        // 初期化を待つ\n        await provider['initializeWebFFT']();\n        return provider;\n\n      case 'native':\n        return new NativeFFTProvider(config.fftSize, config.sampleRate);\n\n      case 'custom':\n        if (!config.customProvider) {\n          throw new AudioInspectError('INVALID_INPUT', 'カスタムプロバイダーが指定されていません');\n        }\n        return config.customProvider;\n\n      default:\n        throw new AudioInspectError(\n          'UNSUPPORTED_FORMAT',\n          `未対応のFFTプロバイダー: ${config.type}`\n        );\n    }\n  }\n\n  /**\n   * 利用可能なプロバイダーをリスト\n   */\n  static getAvailableProviders(): FFTProviderType[] {\n    return ['webfft', 'native'];\n  }\n}\n"],"mappings":"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","names":[]}